/** \file
 *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
 *
 *     -  From the grammar source file : /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g
 *     -                            On : 2011-05-09 15:08:49
 *     -                for the parser : STParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// $ANTLR ${project.version} ${buildNumber} /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g 2011-05-09 15:08:49


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "STParser.h"
/* ----------------------------------------- */

/** Build an AST from a single StringTemplate template */

#pragma mark Tokens
#ifdef EOF
#undef EOF
#endif
#define EOF -1
#define ID 4
#define WS 5
#define STRING 6
#define ANONYMOUS_TEMPLATE 7
#define COMMENT 8
#define LINE_COMMENT 9
#define BIGSTRING 10
#define BIGSTRING_NO_NL 11
#define T_FALSE 12
#define T_TRUE 13
#define IF 14
#define ELSE 15
#define ELSEIF 16
#define ENDIF 17
#define SUPER 18
#define SEMI 19
#define BANG 20
#define ELLIPSIS 21
#define EQUALS 22
#define COLON 23
#define LPAREN 24
#define RPAREN 25
#define LBRACK 26
#define RBRACK 27
#define COMMA 28
#define DOT 29
#define LCURLY 30
#define RCURLY 31
#define TEXT 32
#define LDELIM 33
#define RDELIM 34
#define PIPE 35
#define OR 36
#define AND 37
#define INDENT 38
#define NEWLINE 39
#define AT 40
#define END 41
#define ARGS 42
#define ELEMENTS 43
#define EXEC_FUNC 44
#define EXPR 45
#define INCLUDE 46
#define INCLUDE_IND 47
#define INCLUDE_REGION 48
#define INCLUDE_SUPER 49
#define INCLUDE_SUPER_REGION 50
#define INDENTED_EXPR 51
#define LIST 52
#define MAP 53
#define OPTIONS 54
#define PROP 55
#define PROP_IND 56
#define REGION 57
#define SUBTEMPLATE 58
#define TNULL 59
#define TO_STR 60
#define ZIP 61
/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */

#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_template_in_templateAndEOF190;
static const unsigned long long FOLLOW_template_in_templateAndEOF190_data[] = { 0x0000000000000000LL};
static ANTLRBitSet *FOLLOW_EOF_in_templateAndEOF192;
static const unsigned long long FOLLOW_EOF_in_templateAndEOF192_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_element_in_template206;
static const unsigned long long FOLLOW_element_in_template206_data[] = { 0x000000C300000102LL};
static ANTLRBitSet *FOLLOW_INDENT_in_element224;
static const unsigned long long FOLLOW_INDENT_in_element224_data[] = { 0x0000000000000100LL};
static ANTLRBitSet *FOLLOW_COMMENT_in_element227;
static const unsigned long long FOLLOW_COMMENT_in_element227_data[] = { 0x0000008000000000LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_element229;
static const unsigned long long FOLLOW_NEWLINE_in_element229_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_INDENT_in_element242;
static const unsigned long long FOLLOW_INDENT_in_element242_data[] = { 0x0000008300000100LL};
static ANTLRBitSet *FOLLOW_singleElement_in_element244;
static const unsigned long long FOLLOW_singleElement_in_element244_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_singleElement_in_element266;
static const unsigned long long FOLLOW_singleElement_in_element266_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_compoundElement_in_element276;
static const unsigned long long FOLLOW_compoundElement_in_element276_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_exprTag_in_singleElement295;
static const unsigned long long FOLLOW_exprTag_in_singleElement295_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_TEXT_in_singleElement305;
static const unsigned long long FOLLOW_TEXT_in_singleElement305_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_singleElement315;
static const unsigned long long FOLLOW_NEWLINE_in_singleElement315_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_COMMENT_in_singleElement325;
static const unsigned long long FOLLOW_COMMENT_in_singleElement325_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ifstat_in_compoundElement346;
static const unsigned long long FOLLOW_ifstat_in_compoundElement346_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_region_in_compoundElement356;
static const unsigned long long FOLLOW_region_in_compoundElement356_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_exprTag375;
static const unsigned long long FOLLOW_LDELIM_in_exprTag375_data[] = { 0x0000010045043050LL};
static ANTLRBitSet *FOLLOW_expr_in_exprTag377;
static const unsigned long long FOLLOW_expr_in_exprTag377_data[] = { 0x0000000400080000LL};
static ANTLRBitSet *FOLLOW_SEMI_in_exprTag381;
static const unsigned long long FOLLOW_SEMI_in_exprTag381_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_exprOptions_in_exprTag383;
static const unsigned long long FOLLOW_exprOptions_in_exprTag383_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_exprTag388;
static const unsigned long long FOLLOW_RDELIM_in_exprTag388_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_INDENT_in_region434;
static const unsigned long long FOLLOW_INDENT_in_region434_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_region439;
static const unsigned long long FOLLOW_LDELIM_in_region439_data[] = { 0x0000010000000000LL};
static ANTLRBitSet *FOLLOW_AT_in_region441;
static const unsigned long long FOLLOW_AT_in_region441_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_region443;
static const unsigned long long FOLLOW_ID_in_region443_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_region445;
static const unsigned long long FOLLOW_RDELIM_in_region445_data[] = { 0x000000C300000100LL};
static ANTLRBitSet *FOLLOW_template_in_region457;
static const unsigned long long FOLLOW_template_in_region457_data[] = { 0x0000004200000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_region467;
static const unsigned long long FOLLOW_INDENT_in_region467_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_region470;
static const unsigned long long FOLLOW_LDELIM_in_region470_data[] = { 0x0000020000000000LL};
static ANTLRBitSet *FOLLOW_END_in_region472;
static const unsigned long long FOLLOW_END_in_region472_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_region474;
static const unsigned long long FOLLOW_RDELIM_in_region474_data[] = { 0x0000008000000002LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_region497;
static const unsigned long long FOLLOW_NEWLINE_in_region497_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LCURLY_in_subtemplate599;
static const unsigned long long FOLLOW_LCURLY_in_subtemplate599_data[] = { 0x000000C380000110LL};
static ANTLRBitSet *FOLLOW_ID_in_subtemplate605;
static const unsigned long long FOLLOW_ID_in_subtemplate605_data[] = { 0x0000000810000000LL};
static ANTLRBitSet *FOLLOW_COMMA_in_subtemplate609;
static const unsigned long long FOLLOW_COMMA_in_subtemplate609_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_subtemplate614;
static const unsigned long long FOLLOW_ID_in_subtemplate614_data[] = { 0x0000000810000000LL};
static ANTLRBitSet *FOLLOW_PIPE_in_subtemplate619;
static const unsigned long long FOLLOW_PIPE_in_subtemplate619_data[] = { 0x000000C380000100LL};
static ANTLRBitSet *FOLLOW_template_in_subtemplate624;
static const unsigned long long FOLLOW_template_in_subtemplate624_data[] = { 0x0000004080000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_subtemplate626;
static const unsigned long long FOLLOW_INDENT_in_subtemplate626_data[] = { 0x0000000080000000LL};
static ANTLRBitSet *FOLLOW_RCURLY_in_subtemplate629;
static const unsigned long long FOLLOW_RCURLY_in_subtemplate629_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat690;
static const unsigned long long FOLLOW_INDENT_in_ifstat690_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat693;
static const unsigned long long FOLLOW_LDELIM_in_ifstat693_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_IF_in_ifstat695;
static const unsigned long long FOLLOW_IF_in_ifstat695_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_ifstat697;
static const unsigned long long FOLLOW_LPAREN_in_ifstat697_data[] = { 0x0000010045143050LL};
static ANTLRBitSet *FOLLOW_conditional_in_ifstat701;
static const unsigned long long FOLLOW_conditional_in_ifstat701_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_ifstat703;
static const unsigned long long FOLLOW_RPAREN_in_ifstat703_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat705;
static const unsigned long long FOLLOW_RDELIM_in_ifstat705_data[] = { 0x000000C300000100LL};
static ANTLRBitSet *FOLLOW_template_in_ifstat723;
static const unsigned long long FOLLOW_template_in_ifstat723_data[] = { 0x0000004200000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat739;
static const unsigned long long FOLLOW_INDENT_in_ifstat739_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat742;
static const unsigned long long FOLLOW_LDELIM_in_ifstat742_data[] = { 0x0000000000010000LL};
static ANTLRBitSet *FOLLOW_ELSEIF_in_ifstat744;
static const unsigned long long FOLLOW_ELSEIF_in_ifstat744_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_ifstat746;
static const unsigned long long FOLLOW_LPAREN_in_ifstat746_data[] = { 0x0000010045143050LL};
static ANTLRBitSet *FOLLOW_conditional_in_ifstat750;
static const unsigned long long FOLLOW_conditional_in_ifstat750_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_ifstat752;
static const unsigned long long FOLLOW_RPAREN_in_ifstat752_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat754;
static const unsigned long long FOLLOW_RDELIM_in_ifstat754_data[] = { 0x000000C300000100LL};
static ANTLRBitSet *FOLLOW_template_in_ifstat758;
static const unsigned long long FOLLOW_template_in_ifstat758_data[] = { 0x0000004200000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat777;
static const unsigned long long FOLLOW_INDENT_in_ifstat777_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat780;
static const unsigned long long FOLLOW_LDELIM_in_ifstat780_data[] = { 0x0000000000008000LL};
static ANTLRBitSet *FOLLOW_ELSE_in_ifstat782;
static const unsigned long long FOLLOW_ELSE_in_ifstat782_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat784;
static const unsigned long long FOLLOW_RDELIM_in_ifstat784_data[] = { 0x000000C300000100LL};
static ANTLRBitSet *FOLLOW_template_in_ifstat788;
static const unsigned long long FOLLOW_template_in_ifstat788_data[] = { 0x0000004200000000LL};
static ANTLRBitSet *FOLLOW_INDENT_in_ifstat805;
static const unsigned long long FOLLOW_INDENT_in_ifstat805_data[] = { 0x0000000200000000LL};
static ANTLRBitSet *FOLLOW_LDELIM_in_ifstat811;
static const unsigned long long FOLLOW_LDELIM_in_ifstat811_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_ENDIF_in_ifstat813;
static const unsigned long long FOLLOW_ENDIF_in_ifstat813_data[] = { 0x0000000400000000LL};
static ANTLRBitSet *FOLLOW_RDELIM_in_ifstat823;
static const unsigned long long FOLLOW_RDELIM_in_ifstat823_data[] = { 0x0000008000000002LL};
static ANTLRBitSet *FOLLOW_NEWLINE_in_ifstat846;
static const unsigned long long FOLLOW_NEWLINE_in_ifstat846_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_andConditional_in_conditional990;
static const unsigned long long FOLLOW_andConditional_in_conditional990_data[] = { 0x0000001000000002LL};
static ANTLRBitSet *FOLLOW_OR_in_conditional994;
static const unsigned long long FOLLOW_OR_in_conditional994_data[] = { 0x0000010045143050LL};
static ANTLRBitSet *FOLLOW_andConditional_in_conditional997;
static const unsigned long long FOLLOW_andConditional_in_conditional997_data[] = { 0x0000001000000002LL};
static ANTLRBitSet *FOLLOW_notConditional_in_andConditional1013;
static const unsigned long long FOLLOW_notConditional_in_andConditional1013_data[] = { 0x0000002000000002LL};
static ANTLRBitSet *FOLLOW_AND_in_andConditional1017;
static const unsigned long long FOLLOW_AND_in_andConditional1017_data[] = { 0x0000010045143050LL};
static ANTLRBitSet *FOLLOW_notConditional_in_andConditional1020;
static const unsigned long long FOLLOW_notConditional_in_andConditional1020_data[] = { 0x0000002000000002LL};
static ANTLRBitSet *FOLLOW_BANG_in_notConditional1038;
static const unsigned long long FOLLOW_BANG_in_notConditional1038_data[] = { 0x0000010045143050LL};
static ANTLRBitSet *FOLLOW_notConditional_in_notConditional1041;
static const unsigned long long FOLLOW_notConditional_in_notConditional1041_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_notConditional1051;
static const unsigned long long FOLLOW_memberExpr_in_notConditional1051_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_notConditionalExpr1071;
static const unsigned long long FOLLOW_ID_in_notConditionalExpr1071_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_DOT_in_notConditionalExpr1090;
static const unsigned long long FOLLOW_DOT_in_notConditionalExpr1090_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_notConditionalExpr1094;
static const unsigned long long FOLLOW_ID_in_notConditionalExpr1094_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_DOT_in_notConditionalExpr1145;
static const unsigned long long FOLLOW_DOT_in_notConditionalExpr1145_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_notConditionalExpr1147;
static const unsigned long long FOLLOW_LPAREN_in_notConditionalExpr1147_data[] = { 0x0000010045043050LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_notConditionalExpr1149;
static const unsigned long long FOLLOW_mapExpr_in_notConditionalExpr1149_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_notConditionalExpr1151;
static const unsigned long long FOLLOW_RPAREN_in_notConditionalExpr1151_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_option_in_exprOptions1201;
static const unsigned long long FOLLOW_option_in_exprOptions1201_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_exprOptions1205;
static const unsigned long long FOLLOW_COMMA_in_exprOptions1205_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_option_in_exprOptions1207;
static const unsigned long long FOLLOW_option_in_exprOptions1207_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_ID_in_option1239;
static const unsigned long long FOLLOW_ID_in_option1239_data[] = { 0x0000000000400002LL};
static ANTLRBitSet *FOLLOW_EQUALS_in_option1263;
static const unsigned long long FOLLOW_EQUALS_in_option1263_data[] = { 0x0000010045043050LL};
static ANTLRBitSet *FOLLOW_exprNoComma_in_option1265;
static const unsigned long long FOLLOW_exprNoComma_in_option1265_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_exprNoComma1553;
static const unsigned long long FOLLOW_memberExpr_in_exprNoComma1553_data[] = { 0x0000000000800002LL};
static ANTLRBitSet *FOLLOW_COLON_in_exprNoComma1565;
static const unsigned long long FOLLOW_COLON_in_exprNoComma1565_data[] = { 0x0000000041000010LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_exprNoComma1567;
static const unsigned long long FOLLOW_mapTemplateRef_in_exprNoComma1567_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_expr1671;
static const unsigned long long FOLLOW_mapExpr_in_expr1671_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_mapExpr1688;
static const unsigned long long FOLLOW_memberExpr_in_mapExpr1688_data[] = { 0x0000000010800002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_mapExpr1703;
static const unsigned long long FOLLOW_COMMA_in_mapExpr1703_data[] = { 0x0000010045043050LL};
static ANTLRBitSet *FOLLOW_memberExpr_in_mapExpr1705;
static const unsigned long long FOLLOW_memberExpr_in_mapExpr1705_data[] = { 0x0000000010800000LL};
static ANTLRBitSet *FOLLOW_COLON_in_mapExpr1711;
static const unsigned long long FOLLOW_COLON_in_mapExpr1711_data[] = { 0x0000000041000010LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_mapExpr1713;
static const unsigned long long FOLLOW_mapTemplateRef_in_mapExpr1713_data[] = { 0x0000000000800002LL};
static ANTLRBitSet *FOLLOW_COLON_in_mapExpr1870;
static const unsigned long long FOLLOW_COLON_in_mapExpr1870_data[] = { 0x0000000041000010LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_mapExpr1874;
static const unsigned long long FOLLOW_mapTemplateRef_in_mapExpr1874_data[] = { 0x0000000010800002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_mapExpr1880;
static const unsigned long long FOLLOW_COMMA_in_mapExpr1880_data[] = { 0x0000000041000010LL};
static ANTLRBitSet *FOLLOW_mapTemplateRef_in_mapExpr1884;
static const unsigned long long FOLLOW_mapTemplateRef_in_mapExpr1884_data[] = { 0x0000000010800002LL};
static ANTLRBitSet *FOLLOW_ID_in_mapTemplateRef1981;
static const unsigned long long FOLLOW_ID_in_mapTemplateRef1981_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_mapTemplateRef1983;
static const unsigned long long FOLLOW_LPAREN_in_mapTemplateRef1983_data[] = { 0x0000010047243050LL};
static ANTLRBitSet *FOLLOW_args_in_mapTemplateRef1985;
static const unsigned long long FOLLOW_args_in_mapTemplateRef1985_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_mapTemplateRef1987;
static const unsigned long long FOLLOW_RPAREN_in_mapTemplateRef1987_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_subtemplate_in_mapTemplateRef2032;
static const unsigned long long FOLLOW_subtemplate_in_mapTemplateRef2032_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_mapTemplateRef2044;
static const unsigned long long FOLLOW_LPAREN_in_mapTemplateRef2044_data[] = { 0x0000010045043050LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_mapTemplateRef2046;
static const unsigned long long FOLLOW_mapExpr_in_mapTemplateRef2046_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_mapTemplateRef2050;
static const unsigned long long FOLLOW_RPAREN_in_mapTemplateRef2050_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_mapTemplateRef2052;
static const unsigned long long FOLLOW_LPAREN_in_mapTemplateRef2052_data[] = { 0x0000010047043050LL};
static ANTLRBitSet *FOLLOW_argExprList_in_mapTemplateRef2054;
static const unsigned long long FOLLOW_argExprList_in_mapTemplateRef2054_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_mapTemplateRef2057;
static const unsigned long long FOLLOW_RPAREN_in_mapTemplateRef2057_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_includeExpr_in_memberExpr2088;
static const unsigned long long FOLLOW_includeExpr_in_memberExpr2088_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_DOT_in_memberExpr2107;
static const unsigned long long FOLLOW_DOT_in_memberExpr2107_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_memberExpr2109;
static const unsigned long long FOLLOW_ID_in_memberExpr2109_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_DOT_in_memberExpr2164;
static const unsigned long long FOLLOW_DOT_in_memberExpr2164_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_memberExpr2166;
static const unsigned long long FOLLOW_LPAREN_in_memberExpr2166_data[] = { 0x0000010045043050LL};
static ANTLRBitSet *FOLLOW_mapExpr_in_memberExpr2168;
static const unsigned long long FOLLOW_mapExpr_in_memberExpr2168_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_memberExpr2170;
static const unsigned long long FOLLOW_RPAREN_in_memberExpr2170_data[] = { 0x0000000020000002LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2245;
static const unsigned long long FOLLOW_ID_in_includeExpr2245_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2247;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2247_data[] = { 0x0000010047043050LL};
static ANTLRBitSet *FOLLOW_expr_in_includeExpr2249;
static const unsigned long long FOLLOW_expr_in_includeExpr2249_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2252;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2252_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_SUPER_in_includeExpr2296;
static const unsigned long long FOLLOW_SUPER_in_includeExpr2296_data[] = { 0x0000000020000000LL};
static ANTLRBitSet *FOLLOW_DOT_in_includeExpr2298;
static const unsigned long long FOLLOW_DOT_in_includeExpr2298_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2300;
static const unsigned long long FOLLOW_ID_in_includeExpr2300_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2302;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2302_data[] = { 0x0000010047243050LL};
static ANTLRBitSet *FOLLOW_args_in_includeExpr2304;
static const unsigned long long FOLLOW_args_in_includeExpr2304_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2306;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2306_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2339;
static const unsigned long long FOLLOW_ID_in_includeExpr2339_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2341;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2341_data[] = { 0x0000010047243050LL};
static ANTLRBitSet *FOLLOW_args_in_includeExpr2343;
static const unsigned long long FOLLOW_args_in_includeExpr2343_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2345;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2345_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_AT_in_includeExpr2390;
static const unsigned long long FOLLOW_AT_in_includeExpr2390_data[] = { 0x0000000000040000LL};
static ANTLRBitSet *FOLLOW_SUPER_in_includeExpr2392;
static const unsigned long long FOLLOW_SUPER_in_includeExpr2392_data[] = { 0x0000000020000000LL};
static ANTLRBitSet *FOLLOW_DOT_in_includeExpr2394;
static const unsigned long long FOLLOW_DOT_in_includeExpr2394_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2396;
static const unsigned long long FOLLOW_ID_in_includeExpr2396_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2398;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2398_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2402;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2402_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_AT_in_includeExpr2430;
static const unsigned long long FOLLOW_AT_in_includeExpr2430_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_ID_in_includeExpr2432;
static const unsigned long long FOLLOW_ID_in_includeExpr2432_data[] = { 0x0000000001000000LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_includeExpr2434;
static const unsigned long long FOLLOW_LPAREN_in_includeExpr2434_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_includeExpr2438;
static const unsigned long long FOLLOW_RPAREN_in_includeExpr2438_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_primary_in_includeExpr2478;
static const unsigned long long FOLLOW_primary_in_includeExpr2478_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_primary2497;
static const unsigned long long FOLLOW_ID_in_primary2497_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_STRING_in_primary2507;
static const unsigned long long FOLLOW_STRING_in_primary2507_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_T_TRUE_in_primary2517;
static const unsigned long long FOLLOW_T_TRUE_in_primary2517_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_T_FALSE_in_primary2527;
static const unsigned long long FOLLOW_T_FALSE_in_primary2527_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_subtemplate_in_primary2537;
static const unsigned long long FOLLOW_subtemplate_in_primary2537_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_list_in_primary2547;
static const unsigned long long FOLLOW_list_in_primary2547_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_primary2561;
static const unsigned long long FOLLOW_LPAREN_in_primary2561_data[] = { 0x0000010045143050LL};
static ANTLRBitSet *FOLLOW_conditional_in_primary2564;
static const unsigned long long FOLLOW_conditional_in_primary2564_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_primary2566;
static const unsigned long long FOLLOW_RPAREN_in_primary2566_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_primary2582;
static const unsigned long long FOLLOW_LPAREN_in_primary2582_data[] = { 0x0000010045043050LL};
static ANTLRBitSet *FOLLOW_expr_in_primary2584;
static const unsigned long long FOLLOW_expr_in_primary2584_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_primary2586;
static const unsigned long long FOLLOW_RPAREN_in_primary2586_data[] = { 0x0000000001000002LL};
static ANTLRBitSet *FOLLOW_LPAREN_in_primary2600;
static const unsigned long long FOLLOW_LPAREN_in_primary2600_data[] = { 0x0000010047043050LL};
static ANTLRBitSet *FOLLOW_argExprList_in_primary2602;
static const unsigned long long FOLLOW_argExprList_in_primary2602_data[] = { 0x0000000002000000LL};
static ANTLRBitSet *FOLLOW_RPAREN_in_primary2605;
static const unsigned long long FOLLOW_RPAREN_in_primary2605_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_argExprList_in_args2713;
static const unsigned long long FOLLOW_argExprList_in_args2713_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_namedArg_in_args2723;
static const unsigned long long FOLLOW_namedArg_in_args2723_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_args2727;
static const unsigned long long FOLLOW_COMMA_in_args2727_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_namedArg_in_args2729;
static const unsigned long long FOLLOW_namedArg_in_args2729_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_args2735;
static const unsigned long long FOLLOW_COMMA_in_args2735_data[] = { 0x0000000000200000LL};
static ANTLRBitSet *FOLLOW_ELLIPSIS_in_args2737;
static const unsigned long long FOLLOW_ELLIPSIS_in_args2737_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ELLIPSIS_in_args2757;
static const unsigned long long FOLLOW_ELLIPSIS_in_args2757_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_arg_in_argExprList2776;
static const unsigned long long FOLLOW_arg_in_argExprList2776_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_COMMA_in_argExprList2780;
static const unsigned long long FOLLOW_COMMA_in_argExprList2780_data[] = { 0x0000010045043050LL};
static ANTLRBitSet *FOLLOW_arg_in_argExprList2782;
static const unsigned long long FOLLOW_arg_in_argExprList2782_data[] = { 0x0000000010000002LL};
static ANTLRBitSet *FOLLOW_exprNoComma_in_arg2799;
static const unsigned long long FOLLOW_exprNoComma_in_arg2799_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_ID_in_namedArg2808;
static const unsigned long long FOLLOW_ID_in_namedArg2808_data[] = { 0x0000000000400000LL};
static ANTLRBitSet *FOLLOW_EQUALS_in_namedArg2810;
static const unsigned long long FOLLOW_EQUALS_in_namedArg2810_data[] = { 0x0000010045043050LL};
static ANTLRBitSet *FOLLOW_arg_in_namedArg2812;
static const unsigned long long FOLLOW_arg_in_namedArg2812_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LBRACK_in_list2845;
static const unsigned long long FOLLOW_LBRACK_in_list2845_data[] = { 0x0000000008000000LL};
static ANTLRBitSet *FOLLOW_RBRACK_in_list2847;
static const unsigned long long FOLLOW_RBRACK_in_list2847_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_LBRACK_in_list2864;
static const unsigned long long FOLLOW_LBRACK_in_list2864_data[] = { 0x000001005D043050LL};
static ANTLRBitSet *FOLLOW_listElement_in_list2866;
static const unsigned long long FOLLOW_listElement_in_list2866_data[] = { 0x0000000018000000LL};
static ANTLRBitSet *FOLLOW_COMMA_in_list2870;
static const unsigned long long FOLLOW_COMMA_in_list2870_data[] = { 0x000001005D043050LL};
static ANTLRBitSet *FOLLOW_listElement_in_list2872;
static const unsigned long long FOLLOW_listElement_in_list2872_data[] = { 0x0000000018000000LL};
static ANTLRBitSet *FOLLOW_RBRACK_in_list2877;
static const unsigned long long FOLLOW_RBRACK_in_list2877_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_exprNoComma_in_listElement2900;
static const unsigned long long FOLLOW_exprNoComma_in_listElement2900_data[] = { 0x0000000000000002LL};


#pragma mark Dynamic Global globalAttributeScopeImplementation

#pragma mark Dynamic Rule Scopes ruleAttributeScopeImplementation
@implementation conditional_Scope  /* start of ruleAttributeScopeImplementation */
@synthesize inside;

+ (conditional_Scope *)newconditional_Scope
{
    return [[[conditional_Scope alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* start of conditional_Scope get and set functions */

- (BOOL)getinside { return( inside ); }

- (void)setinside:(BOOL)aVal { inside = aVal; }

/* End of conditional_Scope get and set functions */

@end /* end of ruleAttributeScopeImplementation */



#pragma mark Rule Return Scopes returnScopeImplementation
@implementation STParser_templateAndEOF_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_templateAndEOF_return *)newSTParser_templateAndEOF_return
{
    return [[[STParser_templateAndEOF_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_template_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_template_return *)newSTParser_template_return
{
    return [[[STParser_template_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_element_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_element_return *)newSTParser_element_return
{
    return [[STParser_element_return alloc] init];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_singleElement_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_singleElement_return *)newSTParser_singleElement_return
{
    return [[[STParser_singleElement_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_compoundElement_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_compoundElement_return *)newSTParser_compoundElement_return
{
    return [[[STParser_compoundElement_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_exprTag_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_exprTag_return *)newSTParser_exprTag_return
{
    return [[[STParser_exprTag_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_region_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_region_return *)newSTParser_region_return
{
    return [[[STParser_region_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_subtemplate_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_subtemplate_return *)newSTParser_subtemplate_return
{
    return [[[STParser_subtemplate_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_ifstat_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_ifstat_return *)newSTParser_ifstat_return
{
    return [[[STParser_ifstat_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_conditional_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_conditional_return *)newSTParser_conditional_return
{
    return [[[STParser_conditional_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_andConditional_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_andConditional_return *)newSTParser_andConditional_return
{
    return [[[STParser_andConditional_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_notConditional_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_notConditional_return *)newSTParser_notConditional_return
{
    return [[[STParser_notConditional_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_notConditionalExpr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_notConditionalExpr_return *)newSTParser_notConditionalExpr_return
{
    return [[[STParser_notConditionalExpr_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_exprOptions_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_exprOptions_return *)newSTParser_exprOptions_return
{
    return [[[STParser_exprOptions_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_option_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_option_return *)newSTParser_option_return
{
    return [[[STParser_option_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_exprNoComma_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_exprNoComma_return *)newSTParser_exprNoComma_return
{
    return [[[STParser_exprNoComma_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_expr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_expr_return *)newSTParser_expr_return
{
    return [[[STParser_expr_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_mapExpr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_mapExpr_return *)newSTParser_mapExpr_return
{
    return [[[STParser_mapExpr_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_mapTemplateRef_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_mapTemplateRef_return *)newSTParser_mapTemplateRef_return
{
    return [[[STParser_mapTemplateRef_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_memberExpr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_memberExpr_return *)newSTParser_memberExpr_return
{
    return [[[STParser_memberExpr_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_includeExpr_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_includeExpr_return *)newSTParser_includeExpr_return
{
    return [[[STParser_includeExpr_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_primary_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_primary_return *)newSTParser_primary_return
{
    return [[[STParser_primary_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_args_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_args_return *)newSTParser_args_return
{
    return [[[STParser_args_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_argExprList_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_argExprList_return *)newSTParser_argExprList_return
{
    return [[[STParser_argExprList_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_arg_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_arg_return *)newSTParser_arg_return
{
    return [[[STParser_arg_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_namedArg_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_namedArg_return *)newSTParser_namedArg_return
{
    return [[[STParser_namedArg_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_list_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_list_return *)newSTParser_list_return
{
    return [[[STParser_list_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */


@implementation STParser_listElement_return /* returnScopeImplementation */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
+ (STParser_listElement_return *)newSTParser_listElement_return
{
    return [[[STParser_listElement_return alloc] init] retain];
}

- (id) init
{
    self = [super init];
    return self;
}

/* AST returnScope.methods */
- (CommonTree *)getTree
{
    return tree;
}

- (void) setTree:(CommonTree *)aTree
{
    if (tree != aTree) {
        if ( tree ) [tree release];
        if ( aTree ) [aTree retain];
        tree = aTree;
    }
}

- (void) dealloc
{
    self.tree = nil;
    [super dealloc];
}



@end /* end of returnScope implementation */



@implementation STParser  // line 637

#pragma mark Dynamic Rule Scopes ruleAttributeScope
/* ruleAttributeScope */
static SymbolStack *conditional_stack;


#pragma mark global Attribute Scopes globalAttributeScope
/* ObjC start actions.(actionScope).synthesize */

@synthesize conditional_scope;
@synthesize errMgr;
@synthesize templateToken;

/* ObjC start synthesize() */
/* AST genericParser.synthesize */
/* AST parserProperties */
@synthesize treeAdaptor;

+ (void) initialize
{
    #pragma mark Bitsets
    FOLLOW_template_in_templateAndEOF190 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_templateAndEOF190_data Count:(NSUInteger)1] retain];
    FOLLOW_EOF_in_templateAndEOF192 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_EOF_in_templateAndEOF192_data Count:(NSUInteger)1] retain];
    FOLLOW_element_in_template206 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_element_in_template206_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_element224 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_element224_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMENT_in_element227 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMENT_in_element227_data Count:(NSUInteger)1] retain];
    FOLLOW_NEWLINE_in_element229 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_element229_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_element242 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_element242_data Count:(NSUInteger)1] retain];
    FOLLOW_singleElement_in_element244 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_singleElement_in_element244_data Count:(NSUInteger)1] retain];
    FOLLOW_singleElement_in_element266 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_singleElement_in_element266_data Count:(NSUInteger)1] retain];
    FOLLOW_compoundElement_in_element276 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_compoundElement_in_element276_data Count:(NSUInteger)1] retain];
    FOLLOW_exprTag_in_singleElement295 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprTag_in_singleElement295_data Count:(NSUInteger)1] retain];
    FOLLOW_TEXT_in_singleElement305 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_TEXT_in_singleElement305_data Count:(NSUInteger)1] retain];
    FOLLOW_NEWLINE_in_singleElement315 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_singleElement315_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMENT_in_singleElement325 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMENT_in_singleElement325_data Count:(NSUInteger)1] retain];
    FOLLOW_ifstat_in_compoundElement346 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ifstat_in_compoundElement346_data Count:(NSUInteger)1] retain];
    FOLLOW_region_in_compoundElement356 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_region_in_compoundElement356_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_exprTag375 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_exprTag375_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_exprTag377 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_exprTag377_data Count:(NSUInteger)1] retain];
    FOLLOW_SEMI_in_exprTag381 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_SEMI_in_exprTag381_data Count:(NSUInteger)1] retain];
    FOLLOW_exprOptions_in_exprTag383 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprOptions_in_exprTag383_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_exprTag388 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_exprTag388_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_region434 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_region434_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_region439 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_region439_data Count:(NSUInteger)1] retain];
    FOLLOW_AT_in_region441 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_AT_in_region441_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_region443 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_region443_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_region445 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_region445_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_region457 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_region457_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_region467 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_region467_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_region470 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_region470_data Count:(NSUInteger)1] retain];
    FOLLOW_END_in_region472 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_END_in_region472_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_region474 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_region474_data Count:(NSUInteger)1] retain];
    FOLLOW_NEWLINE_in_region497 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_region497_data Count:(NSUInteger)1] retain];
    FOLLOW_LCURLY_in_subtemplate599 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LCURLY_in_subtemplate599_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_subtemplate605 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_subtemplate605_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_subtemplate609 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_subtemplate609_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_subtemplate614 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_subtemplate614_data Count:(NSUInteger)1] retain];
    FOLLOW_PIPE_in_subtemplate619 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_PIPE_in_subtemplate619_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_subtemplate624 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_subtemplate624_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_subtemplate626 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_subtemplate626_data Count:(NSUInteger)1] retain];
    FOLLOW_RCURLY_in_subtemplate629 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RCURLY_in_subtemplate629_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_ifstat690 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat690_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_ifstat693 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat693_data Count:(NSUInteger)1] retain];
    FOLLOW_IF_in_ifstat695 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_IF_in_ifstat695_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_ifstat697 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_ifstat697_data Count:(NSUInteger)1] retain];
    FOLLOW_conditional_in_ifstat701 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_conditional_in_ifstat701_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_ifstat703 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_ifstat703_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_ifstat705 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat705_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_ifstat723 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_ifstat723_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_ifstat739 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat739_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_ifstat742 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat742_data Count:(NSUInteger)1] retain];
    FOLLOW_ELSEIF_in_ifstat744 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ELSEIF_in_ifstat744_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_ifstat746 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_ifstat746_data Count:(NSUInteger)1] retain];
    FOLLOW_conditional_in_ifstat750 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_conditional_in_ifstat750_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_ifstat752 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_ifstat752_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_ifstat754 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat754_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_ifstat758 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_ifstat758_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_ifstat777 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat777_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_ifstat780 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat780_data Count:(NSUInteger)1] retain];
    FOLLOW_ELSE_in_ifstat782 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ELSE_in_ifstat782_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_ifstat784 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat784_data Count:(NSUInteger)1] retain];
    FOLLOW_template_in_ifstat788 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_template_in_ifstat788_data Count:(NSUInteger)1] retain];
    FOLLOW_INDENT_in_ifstat805 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_INDENT_in_ifstat805_data Count:(NSUInteger)1] retain];
    FOLLOW_LDELIM_in_ifstat811 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LDELIM_in_ifstat811_data Count:(NSUInteger)1] retain];
    FOLLOW_ENDIF_in_ifstat813 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ENDIF_in_ifstat813_data Count:(NSUInteger)1] retain];
    FOLLOW_RDELIM_in_ifstat823 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RDELIM_in_ifstat823_data Count:(NSUInteger)1] retain];
    FOLLOW_NEWLINE_in_ifstat846 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_NEWLINE_in_ifstat846_data Count:(NSUInteger)1] retain];
    FOLLOW_andConditional_in_conditional990 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_andConditional_in_conditional990_data Count:(NSUInteger)1] retain];
    FOLLOW_OR_in_conditional994 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_OR_in_conditional994_data Count:(NSUInteger)1] retain];
    FOLLOW_andConditional_in_conditional997 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_andConditional_in_conditional997_data Count:(NSUInteger)1] retain];
    FOLLOW_notConditional_in_andConditional1013 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_notConditional_in_andConditional1013_data Count:(NSUInteger)1] retain];
    FOLLOW_AND_in_andConditional1017 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_AND_in_andConditional1017_data Count:(NSUInteger)1] retain];
    FOLLOW_notConditional_in_andConditional1020 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_notConditional_in_andConditional1020_data Count:(NSUInteger)1] retain];
    FOLLOW_BANG_in_notConditional1038 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_BANG_in_notConditional1038_data Count:(NSUInteger)1] retain];
    FOLLOW_notConditional_in_notConditional1041 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_notConditional_in_notConditional1041_data Count:(NSUInteger)1] retain];
    FOLLOW_memberExpr_in_notConditional1051 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_notConditional1051_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_notConditionalExpr1071 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_notConditionalExpr1071_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_notConditionalExpr1090 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_notConditionalExpr1090_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_notConditionalExpr1094 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_notConditionalExpr1094_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_notConditionalExpr1145 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_notConditionalExpr1145_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_notConditionalExpr1147 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_notConditionalExpr1147_data Count:(NSUInteger)1] retain];
    FOLLOW_mapExpr_in_notConditionalExpr1149 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_notConditionalExpr1149_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_notConditionalExpr1151 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_notConditionalExpr1151_data Count:(NSUInteger)1] retain];
    FOLLOW_option_in_exprOptions1201 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_option_in_exprOptions1201_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_exprOptions1205 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_exprOptions1205_data Count:(NSUInteger)1] retain];
    FOLLOW_option_in_exprOptions1207 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_option_in_exprOptions1207_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_option1239 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_option1239_data Count:(NSUInteger)1] retain];
    FOLLOW_EQUALS_in_option1263 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_EQUALS_in_option1263_data Count:(NSUInteger)1] retain];
    FOLLOW_exprNoComma_in_option1265 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprNoComma_in_option1265_data Count:(NSUInteger)1] retain];
    FOLLOW_memberExpr_in_exprNoComma1553 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_exprNoComma1553_data Count:(NSUInteger)1] retain];
    FOLLOW_COLON_in_exprNoComma1565 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COLON_in_exprNoComma1565_data Count:(NSUInteger)1] retain];
    FOLLOW_mapTemplateRef_in_exprNoComma1567 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_exprNoComma1567_data Count:(NSUInteger)1] retain];
    FOLLOW_mapExpr_in_expr1671 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_expr1671_data Count:(NSUInteger)1] retain];
    FOLLOW_memberExpr_in_mapExpr1688 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_mapExpr1688_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_mapExpr1703 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_mapExpr1703_data Count:(NSUInteger)1] retain];
    FOLLOW_memberExpr_in_mapExpr1705 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_memberExpr_in_mapExpr1705_data Count:(NSUInteger)1] retain];
    FOLLOW_COLON_in_mapExpr1711 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COLON_in_mapExpr1711_data Count:(NSUInteger)1] retain];
    FOLLOW_mapTemplateRef_in_mapExpr1713 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_mapExpr1713_data Count:(NSUInteger)1] retain];
    FOLLOW_COLON_in_mapExpr1870 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COLON_in_mapExpr1870_data Count:(NSUInteger)1] retain];
    FOLLOW_mapTemplateRef_in_mapExpr1874 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_mapExpr1874_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_mapExpr1880 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_mapExpr1880_data Count:(NSUInteger)1] retain];
    FOLLOW_mapTemplateRef_in_mapExpr1884 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapTemplateRef_in_mapExpr1884_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_mapTemplateRef1981 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_mapTemplateRef1981_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_mapTemplateRef1983 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_mapTemplateRef1983_data Count:(NSUInteger)1] retain];
    FOLLOW_args_in_mapTemplateRef1985 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_args_in_mapTemplateRef1985_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_mapTemplateRef1987 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_mapTemplateRef1987_data Count:(NSUInteger)1] retain];
    FOLLOW_subtemplate_in_mapTemplateRef2032 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_subtemplate_in_mapTemplateRef2032_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_mapTemplateRef2044 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_mapTemplateRef2044_data Count:(NSUInteger)1] retain];
    FOLLOW_mapExpr_in_mapTemplateRef2046 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_mapTemplateRef2046_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_mapTemplateRef2050 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_mapTemplateRef2050_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_mapTemplateRef2052 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_mapTemplateRef2052_data Count:(NSUInteger)1] retain];
    FOLLOW_argExprList_in_mapTemplateRef2054 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_argExprList_in_mapTemplateRef2054_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_mapTemplateRef2057 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_mapTemplateRef2057_data Count:(NSUInteger)1] retain];
    FOLLOW_includeExpr_in_memberExpr2088 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_includeExpr_in_memberExpr2088_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_memberExpr2107 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_memberExpr2107_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_memberExpr2109 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_memberExpr2109_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_memberExpr2164 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_memberExpr2164_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_memberExpr2166 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_memberExpr2166_data Count:(NSUInteger)1] retain];
    FOLLOW_mapExpr_in_memberExpr2168 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_mapExpr_in_memberExpr2168_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_memberExpr2170 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_memberExpr2170_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr2245 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2245_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr2247 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2247_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_includeExpr2249 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_includeExpr2249_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr2252 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2252_data Count:(NSUInteger)1] retain];
    FOLLOW_SUPER_in_includeExpr2296 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_SUPER_in_includeExpr2296_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_includeExpr2298 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_includeExpr2298_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr2300 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2300_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr2302 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2302_data Count:(NSUInteger)1] retain];
    FOLLOW_args_in_includeExpr2304 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_args_in_includeExpr2304_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr2306 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2306_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr2339 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2339_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr2341 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2341_data Count:(NSUInteger)1] retain];
    FOLLOW_args_in_includeExpr2343 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_args_in_includeExpr2343_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr2345 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2345_data Count:(NSUInteger)1] retain];
    FOLLOW_AT_in_includeExpr2390 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_AT_in_includeExpr2390_data Count:(NSUInteger)1] retain];
    FOLLOW_SUPER_in_includeExpr2392 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_SUPER_in_includeExpr2392_data Count:(NSUInteger)1] retain];
    FOLLOW_DOT_in_includeExpr2394 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_DOT_in_includeExpr2394_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr2396 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2396_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr2398 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2398_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr2402 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2402_data Count:(NSUInteger)1] retain];
    FOLLOW_AT_in_includeExpr2430 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_AT_in_includeExpr2430_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_includeExpr2432 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_includeExpr2432_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_includeExpr2434 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_includeExpr2434_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_includeExpr2438 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_includeExpr2438_data Count:(NSUInteger)1] retain];
    FOLLOW_primary_in_includeExpr2478 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_primary_in_includeExpr2478_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_primary2497 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_primary2497_data Count:(NSUInteger)1] retain];
    FOLLOW_STRING_in_primary2507 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_STRING_in_primary2507_data Count:(NSUInteger)1] retain];
    FOLLOW_T_TRUE_in_primary2517 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_T_TRUE_in_primary2517_data Count:(NSUInteger)1] retain];
    FOLLOW_T_FALSE_in_primary2527 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_T_FALSE_in_primary2527_data Count:(NSUInteger)1] retain];
    FOLLOW_subtemplate_in_primary2537 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_subtemplate_in_primary2537_data Count:(NSUInteger)1] retain];
    FOLLOW_list_in_primary2547 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_list_in_primary2547_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_primary2561 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_primary2561_data Count:(NSUInteger)1] retain];
    FOLLOW_conditional_in_primary2564 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_conditional_in_primary2564_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_primary2566 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_primary2566_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_primary2582 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_primary2582_data Count:(NSUInteger)1] retain];
    FOLLOW_expr_in_primary2584 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_primary2584_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_primary2586 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_primary2586_data Count:(NSUInteger)1] retain];
    FOLLOW_LPAREN_in_primary2600 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LPAREN_in_primary2600_data Count:(NSUInteger)1] retain];
    FOLLOW_argExprList_in_primary2602 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_argExprList_in_primary2602_data Count:(NSUInteger)1] retain];
    FOLLOW_RPAREN_in_primary2605 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RPAREN_in_primary2605_data Count:(NSUInteger)1] retain];
    FOLLOW_argExprList_in_args2713 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_argExprList_in_args2713_data Count:(NSUInteger)1] retain];
    FOLLOW_namedArg_in_args2723 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_namedArg_in_args2723_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_args2727 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_args2727_data Count:(NSUInteger)1] retain];
    FOLLOW_namedArg_in_args2729 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_namedArg_in_args2729_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_args2735 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_args2735_data Count:(NSUInteger)1] retain];
    FOLLOW_ELLIPSIS_in_args2737 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ELLIPSIS_in_args2737_data Count:(NSUInteger)1] retain];
    FOLLOW_ELLIPSIS_in_args2757 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ELLIPSIS_in_args2757_data Count:(NSUInteger)1] retain];
    FOLLOW_arg_in_argExprList2776 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_arg_in_argExprList2776_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_argExprList2780 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_argExprList2780_data Count:(NSUInteger)1] retain];
    FOLLOW_arg_in_argExprList2782 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_arg_in_argExprList2782_data Count:(NSUInteger)1] retain];
    FOLLOW_exprNoComma_in_arg2799 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprNoComma_in_arg2799_data Count:(NSUInteger)1] retain];
    FOLLOW_ID_in_namedArg2808 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_ID_in_namedArg2808_data Count:(NSUInteger)1] retain];
    FOLLOW_EQUALS_in_namedArg2810 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_EQUALS_in_namedArg2810_data Count:(NSUInteger)1] retain];
    FOLLOW_arg_in_namedArg2812 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_arg_in_namedArg2812_data Count:(NSUInteger)1] retain];
    FOLLOW_LBRACK_in_list2845 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LBRACK_in_list2845_data Count:(NSUInteger)1] retain];
    FOLLOW_RBRACK_in_list2847 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RBRACK_in_list2847_data Count:(NSUInteger)1] retain];
    FOLLOW_LBRACK_in_list2864 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_LBRACK_in_list2864_data Count:(NSUInteger)1] retain];
    FOLLOW_listElement_in_list2866 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_listElement_in_list2866_data Count:(NSUInteger)1] retain];
    FOLLOW_COMMA_in_list2870 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_COMMA_in_list2870_data Count:(NSUInteger)1] retain];
    FOLLOW_listElement_in_list2872 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_listElement_in_list2872_data Count:(NSUInteger)1] retain];
    FOLLOW_RBRACK_in_list2877 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_RBRACK_in_list2877_data Count:(NSUInteger)1] retain];
    FOLLOW_exprNoComma_in_listElement2900 = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)FOLLOW_exprNoComma_in_listElement2900_data Count:(NSUInteger)1] retain];

    [BaseRecognizer setTokenNames:[[AMutableArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>", 
 @"ID", @"WS", @"STRING", @"ANONYMOUS_TEMPLATE", @"COMMENT", @"LINE_COMMENT", 
 @"BIGSTRING", @"BIGSTRING_NO_NL", @"T_FALSE", @"T_TRUE", @"IF", @"ELSE", 
 @"ELSEIF", @"ENDIF", @"SUPER", @"SEMI", @"BANG", @"ELLIPSIS", @"EQUALS", 
 @"COLON", @"LPAREN", @"RPAREN", @"LBRACK", @"RBRACK", @"COMMA", @"DOT", 
 @"LCURLY", @"RCURLY", @"TEXT", @"LDELIM", @"RDELIM", @"PIPE", @"OR", @"AND", 
 @"INDENT", @"NEWLINE", @"AT", @"END", @"ARGS", @"ELEMENTS", @"EXEC_FUNC", 
 @"EXPR", @"INCLUDE", @"INCLUDE_IND", @"INCLUDE_REGION", @"INCLUDE_SUPER", 
 @"INCLUDE_SUPER_REGION", @"INDENTED_EXPR", @"LIST", @"MAP", @"OPTIONS", 
 @"PROP", @"PROP_IND", @"REGION", @"SUBTEMPLATE", @"TNULL", @"TO_STR", @"ZIP", nil] retain]];
    [BaseRecognizer setGrammarFileName:@"/Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g"];
}

+ (STParser *)newSTParser:(id<TokenStream>)aStream
{
    return [[STParser alloc] initWithTokenStream:aStream];
}

+ (id) newSTParser:(id<TokenStream>)anInput error:(ErrorManager *)anErrMgr token:(STToken *)aTemplateToken
{
    return [[[STParser alloc] init:anInput error:anErrMgr token:aTemplateToken] retain];
}

- (id) initWithTokenStream:(id<TokenStream>)aStream
{
    self = [super initWithTokenStream:aStream State:[[RecognizerSharedState newRecognizerSharedStateWithRuleLen:28+1] retain]];
    if ( self != nil ) {
        /* ruleAttributeScopeInit */
        conditional_scope = [conditional_Scope newconditional_Scope];
        conditional_stack = [SymbolStack newSymbolStackWithLen:30];
        /* start of actions-actionScope-init */
        /* start of init */
        /* AST genericParser.init */
        [self setTreeAdaptor:[[CommonTreeAdaptor newTreeAdaptor] retain]];
    }
    return self;
}

/* ObjC start actions.(actionScope).methods */

- (id) init:(id<TokenStream>)anInput error:(ErrorManager *)anErrMgr token:(STToken *)aTemplateToken
{
    self = [super initWithTokenStream:(id<TokenStream>)anInput];
    if ( self != nil ) {
        [self setTreeAdaptor:[[CommonTreeAdaptor newTreeAdaptor] retain]];
        errMgr = anErrMgr;
        if ( errMgr ) [errMgr retain];
        templateToken = aTemplateToken;
        if ( templateToken ) [templateToken retain];
    }
    return self;
}

- (void) dealloc
{
    if ( conditional_scope ) [conditional_scope release];
    if ( errMgr ) [errMgr release];
    if ( ruleNames ) [ruleNames release];
    if ( templateToken ) [templateToken release];
    if ( treeAdaptor ) [treeAdaptor release];
    
    [super dealloc];
}

- (id) recoverFromMismatchedToken:(id<IntStream>)anInput type:(NSInteger)ttype follow:(ANTLRBitSet *)follow
{
    @throw [MismatchedTokenException newException:ttype Stream:anInput];
}

/* ObjC end actions.(actionScope).methods */
/* ObjC start methods() */
/* AST genericParser.methods */
/* AST parserMethods */
- (id<TreeAdaptor>) getTreeAdaptor
{
	return treeAdaptor;
}

- (void) setTreeAdaptor:(id<TreeAdaptor>)aTreeAdaptor
{
	if (aTreeAdaptor != treeAdaptor) {
        if ( treeAdaptor ) [treeAdaptor release];
		treeAdaptor = aTreeAdaptor;
        if ( treeAdaptor ) [treeAdaptor retain];
	}
}
/* ObjC end methods() */
/* ObjC start rules */
/*
 * $ANTLR start templateAndEOF
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:105:1: templateAndEOF : template EOF -> ( template )? ;
 */
- (STParser_templateAndEOF_return *) templateAndEOF
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_templateAndEOF_return * retval = [STParser_templateAndEOF_return newSTParser_templateAndEOF_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *EOF2 = nil;
         STParser_template_return * template1 = nil ;
         

        CommonTree *EOF2_tree=nil;
        RewriteRuleTokenStream *stream_EOF =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token EOF"] retain];
        RewriteRuleSubtreeStream *stream_template =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:105:16: ( template EOF -> ( template )? ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:105:18: template EOF // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_templateAndEOF190];
        template1 = [self template];

        [self popFollow];


        [stream_template addElement:[template1 getTree]];

        EOF2=(STToken *)[self match:input TokenType:EOF Follow:FOLLOW_EOF_in_templateAndEOF192];  
            [stream_EOF addElement:EOF2];


        // AST REWRITE
        // elements: template
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 105:31: -> ( template )?
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:105:34: ( template )?
            if ( [stream_template hasNext] ) {
            	[treeAdaptor addChild:[stream_template nextTree] toTree:root_0];

            }
            [stream_template reset];

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_EOF release];
        [stream_template release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end templateAndEOF */

/*
 * $ANTLR start template
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:107:1: template : ( element )* ;
 */
- (STParser_template_return *) template
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_template_return * retval = [STParser_template_return newSTParser_template_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
         STParser_element_return * element3 = nil ;
         


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:107:10: ( ( element )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:107:12: ( element )* // alt
        {
        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];




        do {
            NSInteger alt1=2;
            switch ([input LA:1]) { // dfaLoopbackStateSwitch
                case INDENT: ;
                    {
                    NSInteger LA1_2 = [input LA:2];
                    if ( (LA1_2==LDELIM) ) {
                        NSInteger LA1_5 = [input LA:3];
                        if ( (LA1_5==ID||LA1_5==STRING||(LA1_5 >= T_FALSE && LA1_5 <= IF)||LA1_5==SUPER||LA1_5==LPAREN||LA1_5==LBRACK||LA1_5==LCURLY||LA1_5==AT) ) {
                            alt1=1;
                        }


                    }
                    else if ( (LA1_2==COMMENT||LA1_2==TEXT||LA1_2==NEWLINE) ) {
                        alt1=1;
                    }


                    }
                    break;
                case LDELIM: ;
                    {
                    NSInteger LA1_3 = [input LA:2];
                    if ( (LA1_3==ID||LA1_3==STRING||(LA1_3 >= T_FALSE && LA1_3 <= IF)||LA1_3==SUPER||LA1_3==LPAREN||LA1_3==LBRACK||LA1_3==LCURLY||LA1_3==AT) ) {
                        alt1=1;
                    }


                    }
                    break;
                case COMMENT: ;
                case TEXT: ;
                case NEWLINE: ;
                    {
                    alt1=1;
                    }
                    break;

            }

            switch (alt1) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:107:12: element // alt
                    {

                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_element_in_template206];
                    element3 = [self element];

                    [self popFollow];


                    [treeAdaptor addChild:[element3 getTree] toTree:root_0];

                    }
                    break;

                default :
                    goto loop1;
            }
        } while (YES);
        loop1: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end template */

/*
 * $ANTLR start element
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:109:1: element : ({...}? ( INDENT )? COMMENT NEWLINE ->| INDENT singleElement -> ^( INDENTED_EXPR INDENT ( singleElement )? ) | singleElement | compoundElement );
 */
- (STParser_element_return *) element
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_element_return * retval = [STParser_element_return newSTParser_element_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *INDENT4 = nil;
        STToken *COMMENT5 = nil;
        STToken *NEWLINE6 = nil;
        STToken *INDENT7 = nil;
         STParser_singleElement_return * singleElement8 = nil ;
         
         STParser_singleElement_return * singleElement9 = nil ;
         
         STParser_compoundElement_return * compoundElement10 = nil ;
         

        CommonTree *INDENT4_tree=nil;
        CommonTree *COMMENT5_tree=nil;
        CommonTree *NEWLINE6_tree=nil;
        CommonTree *INDENT7_tree=nil;
        RewriteRuleTokenStream *stream_NEWLINE =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token NEWLINE"] retain];
        RewriteRuleTokenStream *stream_COMMENT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMENT"] retain];
        RewriteRuleTokenStream *stream_INDENT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"] retain];
        RewriteRuleSubtreeStream *stream_singleElement =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule singleElement"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:110:5: ({...}? ( INDENT )? COMMENT NEWLINE ->| INDENT singleElement -> ^( INDENTED_EXPR INDENT ( singleElement )? ) | singleElement | compoundElement ) //ruleblock
        NSInteger alt3=4;
        unichar charLA3 = [input LA:1];
        switch (charLA3) {
            case INDENT: ;
                {
                unichar charLA3 = [input LA:2];
                switch (charLA3) {
                    case COMMENT: ;
                        {
                        NSInteger LA3_5 = [input LA:3];

                        if ( (LA3_5==NEWLINE) ) {
                            NSInteger LA3_11 = [input LA:4];

                            if ( ((STToken *)[input LT:1]).charPositionInLine == 0 ) {
                                alt3=1;
                            }
                            else if ( (YES) ) {
                                alt3=2;
                            }
                            else {
                                NoViableAltException *nvae = [NoViableAltException newException:3 state:11 stream:input];
                                nvae.c = LA3_11;
                                @throw nvae;

                            }
                        }
                        else if ( (LA3_5==EOF||LA3_5==COMMENT||(LA3_5 >= RCURLY && LA3_5 <= LDELIM)||LA3_5==INDENT) ) {
                            alt3=2;
                        }
                        else {
                            NoViableAltException *nvae = [NoViableAltException newException:3 state:5 stream:input];
                            nvae.c = LA3_5;
                            @throw nvae;

                        }
                        }
                        break;
                    case LDELIM: ;
                        {
                        unichar charLA3 = [input LA:3];
                        switch (charLA3) {
                            case IF: ;
                                {
                                alt3=4;
                                }
                                break;
                            case AT: ;
                                {
                                NSInteger LA3_12 = [input LA:4];

                                if ( (LA3_12==ID) ) {
                                    NSInteger LA3_15 = [input LA:5];

                                    if ( (LA3_15==RDELIM) ) {
                                        alt3=4;
                                    }
                                    else if ( (LA3_15==LPAREN) ) {
                                        alt3=2;
                                    }
                                    else {
                                        NoViableAltException *nvae = [NoViableAltException newException:3 state:15 stream:input];
                                        nvae.c = LA3_15;
                                        @throw nvae;

                                    }
                                }
                                else if ( (LA3_12==SUPER) ) {
                                    alt3=2;
                                }
                                else {
                                    NoViableAltException *nvae = [NoViableAltException newException:3 state:12 stream:input];
                                    nvae.c = LA3_12;
                                    @throw nvae;

                                }
                                }
                                break;
                            case ID: ;
                            case STRING: ;
                            case T_FALSE: ;
                            case T_TRUE: ;
                            case SUPER: ;
                            case LPAREN: ;
                            case LBRACK: ;
                            case LCURLY: ;
                                {
                                alt3=2;
                                }
                                break;

                        default: ;
                            NoViableAltException *nvae = [NoViableAltException newException:3 state:6 stream:input];
                            nvae.c = charLA3;
                            @throw nvae;

                        }

                        }
                        break;
                    case TEXT: ;
                    case NEWLINE: ;
                        {
                        alt3=2;
                        }
                        break;

                default: ;
                    NoViableAltException *nvae = [NoViableAltException newException:3 state:1 stream:input];
                    nvae.c = charLA3;
                    @throw nvae;

                }

                }
                break;
            case COMMENT: ;
                {
                NSInteger LA3_2 = [input LA:2];

                if ( (LA3_2==NEWLINE) ) {
                    NSInteger LA3_8 = [input LA:3];

                    if ( ((STToken *)[input LT:1]).charPositionInLine == 0 ) {
                        alt3=1;
                    }
                    else if ( (YES) ) {
                        alt3=3;
                    }
                    else {
                        NoViableAltException *nvae = [NoViableAltException newException:3 state:8 stream:input];
                        nvae.c = LA3_8;
                        @throw nvae;

                    }
                }
                else if ( (LA3_2==EOF||LA3_2==COMMENT||(LA3_2 >= RCURLY && LA3_2 <= LDELIM)||LA3_2==INDENT) ) {
                    alt3=3;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:3 state:2 stream:input];
                    nvae.c = LA3_2;
                    @throw nvae;

                }
                }
                break;
            case LDELIM: ;
                {
                unichar charLA3 = [input LA:2];
                switch (charLA3) {
                    case IF: ;
                        {
                        alt3=4;
                        }
                        break;
                    case AT: ;
                        {
                        NSInteger LA3_10 = [input LA:3];

                        if ( (LA3_10==ID) ) {
                            NSInteger LA3_14 = [input LA:4];

                            if ( (LA3_14==RDELIM) ) {
                                alt3=4;
                            }
                            else if ( (LA3_14==LPAREN) ) {
                                alt3=3;
                            }
                            else {
                                NoViableAltException *nvae = [NoViableAltException newException:3 state:14 stream:input];
                                nvae.c = LA3_14;
                                @throw nvae;

                            }
                        }
                        else if ( (LA3_10==SUPER) ) {
                            alt3=3;
                        }
                        else {
                            NoViableAltException *nvae = [NoViableAltException newException:3 state:10 stream:input];
                            nvae.c = LA3_10;
                            @throw nvae;

                        }
                        }
                        break;
                    case ID: ;
                    case STRING: ;
                    case T_FALSE: ;
                    case T_TRUE: ;
                    case SUPER: ;
                    case LPAREN: ;
                    case LBRACK: ;
                    case LCURLY: ;
                        {
                        alt3=3;
                        }
                        break;

                default: ;
                    NoViableAltException *nvae = [NoViableAltException newException:3 state:3 stream:input];
                    nvae.c = charLA3;
                    @throw nvae;

                }

                }
                break;
            case TEXT: ;
            case NEWLINE: ;
                {
                alt3=3;
                }
                break;

        default: ;
            NoViableAltException *nvae = [NoViableAltException newException:3 state:0 stream:input];
            nvae.c = charLA3;
            @throw nvae;

        }

        switch (alt3) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:110:9: {...}? ( INDENT )? COMMENT NEWLINE // alt
                {
                if ( !(((STToken *)[input LT:1]).charPositionInLine == 0) ) {
                    @throw [FailedPredicateException newException:@"element" predicate:@"[input LT:1].charPositionInLine == 0 " stream:input];
                }

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:110:50: ( INDENT )? // block
                NSInteger alt2=2;
                NSInteger LA2_0 = [input LA:1];

                if ( (LA2_0==INDENT) ) {
                    alt2=1;
                }
                switch (alt2) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:110:50: INDENT // alt
                        {

                        INDENT4=(STToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_element224];  
                            [stream_INDENT addElement:INDENT4];


                        }
                        break;

                }


                COMMENT5=(STToken *)[self match:input TokenType:COMMENT Follow:FOLLOW_COMMENT_in_element227];  
                    [stream_COMMENT addElement:COMMENT5];


                NEWLINE6=(STToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_element229];  
                    [stream_NEWLINE addElement:NEWLINE6];


                // AST REWRITE
                // elements: 
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 110:74: ->
                {
                    root_0 = nil;
                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:111:9: INDENT singleElement // alt
                {

                INDENT7=(STToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_element242];  
                    [stream_INDENT addElement:INDENT7];


                /* ruleRef */
                [self pushFollow:FOLLOW_singleElement_in_element244];
                singleElement8 = [self singleElement];

                [self popFollow];


                [stream_singleElement addElement:[singleElement8 getTree]];

                // AST REWRITE
                // elements: INDENT, singleElement
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 111:30: -> ^( INDENTED_EXPR INDENT ( singleElement )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:111:33: ^( INDENTED_EXPR INDENT ( singleElement )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:INDENTED_EXPR Text:@"INDENTED_EXPR"] retain]
                         old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:
                                    [stream_INDENT nextNode]
                         toTree:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:111:56: ( singleElement )?
                        if ( [stream_singleElement hasNext] ) {
                        	[treeAdaptor addChild:[stream_singleElement nextTree] toTree:root_1];

                        }
                        [stream_singleElement reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:112:9: singleElement // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_singleElement_in_element266];
                singleElement9 = [self singleElement];

                [self popFollow];


                [treeAdaptor addChild:[singleElement9 getTree] toTree:root_0];

                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:113:9: compoundElement // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_compoundElement_in_element276];
                compoundElement10 = [self compoundElement];

                [self popFollow];


                [treeAdaptor addChild:[compoundElement10 getTree] toTree:root_0];

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_NEWLINE release];
        [stream_COMMENT release];
        [stream_INDENT release];
        [stream_singleElement release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end element */

/*
 * $ANTLR start singleElement
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:116:1: singleElement : ( exprTag | TEXT | NEWLINE | COMMENT !);
 */
- (STParser_singleElement_return *) singleElement
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_singleElement_return * retval = [STParser_singleElement_return newSTParser_singleElement_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *TEXT12 = nil;
        STToken *NEWLINE13 = nil;
        STToken *COMMENT14 = nil;
         STParser_exprTag_return * exprTag11 = nil ;
         

        CommonTree *TEXT12_tree=nil;
        CommonTree *NEWLINE13_tree=nil;
        CommonTree *COMMENT14_tree=nil;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:117:5: ( exprTag | TEXT | NEWLINE | COMMENT !) //ruleblock
        NSInteger alt4=4;
        unichar charLA4 = [input LA:1];
        switch (charLA4) {
            case LDELIM: ;
                {
                alt4=1;
                }
                break;
            case TEXT: ;
                {
                alt4=2;
                }
                break;
            case NEWLINE: ;
                {
                alt4=3;
                }
                break;
            case COMMENT: ;
                {
                alt4=4;
                }
                break;

        default: ;
            NoViableAltException *nvae = [NoViableAltException newException:4 state:0 stream:input];
            nvae.c = charLA4;
            @throw nvae;

        }

        switch (alt4) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:117:9: exprTag // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_exprTag_in_singleElement295];
                exprTag11 = [self exprTag];

                [self popFollow];


                [treeAdaptor addChild:[exprTag11 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:118:9: TEXT // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser tokenRef */
                TEXT12=(STToken *)[self match:input TokenType:TEXT Follow:FOLLOW_TEXT_in_singleElement305]; 
                TEXT12_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[[treeAdaptor create:TEXT12] retain]
                ;
                [treeAdaptor addChild:TEXT12_tree  toTree:root_0];


                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:119:9: NEWLINE // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser tokenRef */
                NEWLINE13=(STToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_singleElement315]; 
                NEWLINE13_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[[treeAdaptor create:NEWLINE13] retain]
                ;
                [treeAdaptor addChild:NEWLINE13_tree  toTree:root_0];


                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:120:9: COMMENT ! // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                COMMENT14=(STToken *)[self match:input TokenType:COMMENT Follow:FOLLOW_COMMENT_in_singleElement325]; 

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end singleElement */

/*
 * $ANTLR start compoundElement
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:123:1: compoundElement : ( ifstat | region );
 */
- (STParser_compoundElement_return *) compoundElement
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_compoundElement_return * retval = [STParser_compoundElement_return newSTParser_compoundElement_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
         STParser_ifstat_return * ifstat15 = nil ;
         
         STParser_region_return * region16 = nil ;
         


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:124:5: ( ifstat | region ) //ruleblock
        NSInteger alt5=2;
        NSInteger LA5_0 = [input LA:1];

        if ( (LA5_0==INDENT) ) {
            NSInteger LA5_1 = [input LA:2];

            if ( (LA5_1==LDELIM) ) {
                NSInteger LA5_2 = [input LA:3];

                if ( (LA5_2==IF) ) {
                    alt5=1;
                }
                else if ( (LA5_2==AT) ) {
                    alt5=2;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:5 state:2 stream:input];
                    nvae.c = LA5_2;
                    @throw nvae;

                }
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:5 state:1 stream:input];
                nvae.c = LA5_1;
                @throw nvae;

            }
        }
        else if ( (LA5_0==LDELIM) ) {
            NSInteger LA5_2 = [input LA:2];

            if ( (LA5_2==IF) ) {
                alt5=1;
            }
            else if ( (LA5_2==AT) ) {
                alt5=2;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:5 state:2 stream:input];
                nvae.c = LA5_2;
                @throw nvae;

            }
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:5 state:0 stream:input];
            nvae.c = LA5_0;
            @throw nvae;

        }
        switch (alt5) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:124:9: ifstat // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_ifstat_in_compoundElement346];
                ifstat15 = [self ifstat];

                [self popFollow];


                [treeAdaptor addChild:[ifstat15 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:125:9: region // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_region_in_compoundElement356];
                region16 = [self region];

                [self popFollow];


                [treeAdaptor addChild:[region16 getTree] toTree:root_0];

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end compoundElement */

/*
 * $ANTLR start exprTag
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:128:1: exprTag : LDELIM expr ( ';' exprOptions )? RDELIM -> ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? ) ;
 */
- (STParser_exprTag_return *) exprTag
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_exprTag_return * retval = [STParser_exprTag_return newSTParser_exprTag_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *LDELIM17 = nil;
        STToken *char_literal19 = nil;
        STToken *RDELIM21 = nil;
         STParser_expr_return * expr18 = nil ;
         
         STParser_exprOptions_return * exprOptions20 = nil ;
         

        CommonTree *LDELIM17_tree=nil;
        CommonTree *char_literal19_tree=nil;
        CommonTree *RDELIM21_tree=nil;
        RewriteRuleTokenStream *stream_RDELIM =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RDELIM"] retain];
        RewriteRuleTokenStream *stream_LDELIM =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LDELIM"] retain];
        RewriteRuleTokenStream *stream_SEMI =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token SEMI"] retain];
        RewriteRuleSubtreeStream *stream_exprOptions =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule exprOptions"] retain];
        RewriteRuleSubtreeStream *stream_expr =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:129:5: ( LDELIM expr ( ';' exprOptions )? RDELIM -> ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:129:9: LDELIM expr ( ';' exprOptions )? RDELIM // alt
        {

        LDELIM17=(STToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_exprTag375];  
            [stream_LDELIM addElement:LDELIM17];


        /* ruleRef */
        [self pushFollow:FOLLOW_expr_in_exprTag377];
        expr18 = [self expr];

        [self popFollow];


        [stream_expr addElement:[expr18 getTree]];

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:129:21: ( ';' exprOptions )? // block
        NSInteger alt6=2;
        NSInteger LA6_0 = [input LA:1];

        if ( (LA6_0==SEMI) ) {
            alt6=1;
        }
        switch (alt6) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:129:23: ';' exprOptions // alt
                {

                char_literal19=(STToken *)[self match:input TokenType:SEMI Follow:FOLLOW_SEMI_in_exprTag381];  
                    [stream_SEMI addElement:char_literal19];


                /* ruleRef */
                [self pushFollow:FOLLOW_exprOptions_in_exprTag383];
                exprOptions20 = [self exprOptions];

                [self popFollow];


                [stream_exprOptions addElement:[exprOptions20 getTree]];

                }
                break;

        }


        RDELIM21=(STToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_exprTag388];  
            [stream_RDELIM addElement:RDELIM21];


        // AST REWRITE
        // elements: expr, exprOptions
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 130:9: -> ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:130:12: ^( EXPR[$LDELIM,@\"EXPR\"] expr ( exprOptions )? )
            {
                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                        [[treeAdaptor createTree:EXPR FromToken:LDELIM17 Text:@"EXPR"] retain]
                 old:root_1];

                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:130:41: ( exprOptions )?
                if ( [stream_exprOptions hasNext] ) {
                	[treeAdaptor addChild:[stream_exprOptions nextTree] toTree:root_1];

                }
                [stream_exprOptions reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_RDELIM release];
        [stream_LDELIM release];
        [stream_SEMI release];
        [stream_exprOptions release];
        [stream_expr release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end exprTag */

/*
 * $ANTLR start region
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:133:1: region : (i= INDENT )? x= LDELIM '@' ID RDELIM template ( INDENT )? LDELIM '@end' RDELIM ({...}? => NEWLINE )? -> {indent!=nil}? ^( INDENTED_EXPR $i ^( REGION[$x] ID ( template )? ) ) -> ^( REGION[$x] ID ( template )? ) ;
 */
- (STParser_region_return *) region
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_region_return * retval = [STParser_region_return newSTParser_region_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

     STToken *indent=nil; 
    @try {
        /* AST ruleLabelDefs */
        STToken *i = nil;
        STToken *x = nil;
        STToken *char_literal22 = nil;
        STToken *ID23 = nil;
        STToken *RDELIM24 = nil;
        STToken *INDENT26 = nil;
        STToken *LDELIM27 = nil;
        STToken *string_literal28 = nil;
        STToken *RDELIM29 = nil;
        STToken *NEWLINE30 = nil;
         STParser_template_return * template25 = nil ;
         

        CommonTree *i_tree=nil;
        CommonTree *x_tree=nil;
        CommonTree *char_literal22_tree=nil;
        CommonTree *ID23_tree=nil;
        CommonTree *RDELIM24_tree=nil;
        CommonTree *INDENT26_tree=nil;
        CommonTree *LDELIM27_tree=nil;
        CommonTree *string_literal28_tree=nil;
        CommonTree *RDELIM29_tree=nil;
        CommonTree *NEWLINE30_tree=nil;
        RewriteRuleTokenStream *stream_AT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token AT"] retain];
        RewriteRuleTokenStream *stream_RDELIM =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RDELIM"] retain];
        RewriteRuleTokenStream *stream_NEWLINE =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token NEWLINE"] retain];
        RewriteRuleTokenStream *stream_ID =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        RewriteRuleTokenStream *stream_END =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token END"] retain];
        RewriteRuleTokenStream *stream_LDELIM =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LDELIM"] retain];
        RewriteRuleTokenStream *stream_INDENT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"] retain];
        RewriteRuleSubtreeStream *stream_template =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:135:5: ( (i= INDENT )? x= LDELIM '@' ID RDELIM template ( INDENT )? LDELIM '@end' RDELIM ({...}? => NEWLINE )? -> {indent!=nil}? ^( INDENTED_EXPR $i ^( REGION[$x] ID ( template )? ) ) -> ^( REGION[$x] ID ( template )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:135:9: (i= INDENT )? x= LDELIM '@' ID RDELIM template ( INDENT )? LDELIM '@end' RDELIM ({...}? => NEWLINE )? // alt
        {

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:135:10: (i= INDENT )? // block
        NSInteger alt7=2;
        NSInteger LA7_0 = [input LA:1];

        if ( (LA7_0==INDENT) ) {
            alt7=1;
        }
        switch (alt7) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:135:10: i= INDENT // alt
                {

                i=(STToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_region434];  
                    [stream_INDENT addElement:i];


                }
                break;

        }


        x=(STToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_region439];  
            [stream_LDELIM addElement:x];


        char_literal22=(STToken *)[self match:input TokenType:AT Follow:FOLLOW_AT_in_region441];  
            [stream_AT addElement:char_literal22];


        ID23=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_region443];  
            [stream_ID addElement:ID23];


        RDELIM24=(STToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_region445];  
            [stream_RDELIM addElement:RDELIM24];



         if ([input LA:1] != NEWLINE) indent=i;


        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_region457];
        template25 = [self template];

        [self popFollow];


        [stream_template addElement:[template25 getTree]];

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:137:9: ( INDENT )? // block
        NSInteger alt8=2;
        NSInteger LA8_0 = [input LA:1];

        if ( (LA8_0==INDENT) ) {
            alt8=1;
        }
        switch (alt8) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:137:9: INDENT // alt
                {

                INDENT26=(STToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_region467];  
                    [stream_INDENT addElement:INDENT26];


                }
                break;

        }


        LDELIM27=(STToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_region470];  
            [stream_LDELIM addElement:LDELIM27];


        string_literal28=(STToken *)[self match:input TokenType:END Follow:FOLLOW_END_in_region472];  
            [stream_END addElement:string_literal28];


        RDELIM29=(STToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_region474];  
            [stream_RDELIM addElement:RDELIM29];


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:139:9: ({...}? => NEWLINE )? // block
        NSInteger alt9=2;
        NSInteger LA9_0 = [input LA:1];

        if ( (LA9_0==NEWLINE) ) {
            NSInteger LA9_1 = [input LA:2];

            if ( ((((STToken *)retval.start).line!= [input LT:1].line)) ) {
                alt9=1;
            }
        }
        switch (alt9) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:139:10: {...}? => NEWLINE // alt
                {
                if ( !(((STToken *)retval.start).line != ((STToken *)[input LT:1]).line) ) {
                    @throw [FailedPredicateException newException:@"region" predicate:@" $region.start.line != [input LT:1].line" stream:input];
                }

                NEWLINE30=(STToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_region497];  
                    [stream_NEWLINE addElement:NEWLINE30];


                }
                break;

        }


        // AST REWRITE
        // elements: i, ID, template, ID, template
        // token labels: i
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleTokenStream *stream_i =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor description:@"token i" element:i] retain];
        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 140:9: -> {indent!=nil}? ^( INDENTED_EXPR $i ^( REGION[$x] ID ( template )? ) )
        if (indent!=nil) {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:141:12: ^( INDENTED_EXPR $i ^( REGION[$x] ID ( template )? ) )
            {
                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                        [[treeAdaptor createTree:INDENTED_EXPR Text:@"INDENTED_EXPR"] retain]
                 old:root_1];

                [treeAdaptor addChild:[stream_i nextNode] toTree:root_1];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:141:31: ^( REGION[$x] ID ( template )? )
                {
                    CommonTree *root_2 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                    root_2 = (CommonTree *)[treeAdaptor becomeRoot:
                            [[treeAdaptor createTree:REGION FromToken:x Text:@"REGION"] retain]
                     old:root_2];

                     // TODO: args: 
                    [treeAdaptor addChild:
                                [stream_ID nextNode]
                     toTree:root_2];

                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:141:47: ( template )?
                    if ( [stream_template hasNext] ) {
                    	[treeAdaptor addChild:[stream_template nextTree] toTree:root_2];

                    }
                    [stream_template reset];

                    [treeAdaptor addChild:root_2 toTree:root_1];
                }

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        else // 142:9: -> ^( REGION[$x] ID ( template )? )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:142:31: ^( REGION[$x] ID ( template )? )
            {
                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                        [[treeAdaptor createTree:REGION FromToken:x Text:@"REGION"] retain]
                 old:root_1];

                 // TODO: args: 
                [treeAdaptor addChild:
                            [stream_ID nextNode]
                 toTree:root_1];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:142:47: ( template )?
                if ( [stream_template hasNext] ) {
                	[treeAdaptor addChild:[stream_template nextTree] toTree:root_1];

                }
                [stream_template reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_AT release];
        [stream_RDELIM release];
        [stream_NEWLINE release];
        [stream_ID release];
        [stream_END release];
        [stream_LDELIM release];
        [stream_INDENT release];
        [stream_template release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end region */

/*
 * $ANTLR start subtemplate
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:145:1: subtemplate : lc= '{' (ids+= ID ( ',' ids+= ID )* '|' )? template ( INDENT )? '}' -> ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* ( template )? ) ;
 */
- (STParser_subtemplate_return *) subtemplate
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_subtemplate_return * retval = [STParser_subtemplate_return newSTParser_subtemplate_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *lc = nil;
        STToken *char_literal31 = nil;
        STToken *char_literal32 = nil;
        STToken *INDENT34 = nil;
        STToken *char_literal35 = nil;
        STToken *ids = nil;
        AMutableArray *list_ids = nil;
         STParser_template_return * template33 = nil ;
         

        CommonTree *lc_tree=nil;
        CommonTree *char_literal31_tree=nil;
        CommonTree *char_literal32_tree=nil;
        CommonTree *INDENT34_tree=nil;
        CommonTree *char_literal35_tree=nil;
        CommonTree *ids_tree = nil;
        RewriteRuleTokenStream *stream_LCURLY =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LCURLY"] retain];
        RewriteRuleTokenStream *stream_PIPE =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token PIPE"] retain];
        RewriteRuleTokenStream *stream_ID =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        RewriteRuleTokenStream *stream_COMMA =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        RewriteRuleTokenStream *stream_INDENT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"] retain];
        RewriteRuleTokenStream *stream_RCURLY =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RCURLY"] retain];
        RewriteRuleSubtreeStream *stream_template =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:146:5: (lc= '{' (ids+= ID ( ',' ids+= ID )* '|' )? template ( INDENT )? '}' -> ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* ( template )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:146:9: lc= '{' (ids+= ID ( ',' ids+= ID )* '|' )? template ( INDENT )? '}' // alt
        {

        lc=(STToken *)[self match:input TokenType:LCURLY Follow:FOLLOW_LCURLY_in_subtemplate599];  
            [stream_LCURLY addElement:lc];


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:146:16: (ids+= ID ( ',' ids+= ID )* '|' )? // block
        NSInteger alt11=2;
        NSInteger LA11_0 = [input LA:1];

        if ( (LA11_0==ID) ) {
            alt11=1;
        }
        switch (alt11) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:146:17: ids+= ID ( ',' ids+= ID )* '|' // alt
                {

                ids=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_subtemplate605];  
                    [stream_ID addElement:ids];

                if (list_ids == nil) list_ids = [[AMutableArray arrayWithCapacity:5] retain];
                [list_ids addObject:ids];



                do {
                    NSInteger alt10=2;
                    NSInteger LA10_0 = [input LA:1];
                    if ( (LA10_0==COMMA) ) {
                        alt10=1;
                    }


                    switch (alt10) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:146:28: ',' ids+= ID // alt
                            {

                            char_literal31=(STToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_subtemplate609];  
                                [stream_COMMA addElement:char_literal31];


                            ids=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_subtemplate614];  
                                [stream_ID addElement:ids];

                            if (list_ids == nil) list_ids = [[AMutableArray arrayWithCapacity:5] retain];
                            [list_ids addObject:ids];


                            }
                            break;

                        default :
                            goto loop10;
                    }
                } while (YES);
                loop10: ;


                char_literal32=(STToken *)[self match:input TokenType:PIPE Follow:FOLLOW_PIPE_in_subtemplate619];  
                    [stream_PIPE addElement:char_literal32];


                }
                break;

        }


        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_subtemplate624];
        template33 = [self template];

        [self popFollow];


        [stream_template addElement:[template33 getTree]];

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:146:60: ( INDENT )? // block
        NSInteger alt12=2;
        NSInteger LA12_0 = [input LA:1];

        if ( (LA12_0==INDENT) ) {
            alt12=1;
        }
        switch (alt12) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:146:60: INDENT // alt
                {

                INDENT34=(STToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_subtemplate626];  
                    [stream_INDENT addElement:INDENT34];


                }
                break;

        }


        char_literal35=(STToken *)[self match:input TokenType:RCURLY Follow:FOLLOW_RCURLY_in_subtemplate629];  
            [stream_RCURLY addElement:char_literal35];


        // AST REWRITE
        // elements: ids, template
        // token labels: 
        // rule labels: retval
        // token list labels: ids
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleTokenStream *stream_ids =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                description:@"token ids" elements:list_ids] retain];
        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 148:9: -> ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* ( template )? )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:148:12: ^( SUBTEMPLATE[$lc,@\"SUBTEMPLATE\"] ( ^( ARGS $ids) )* ( template )? )
            {
                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                        [[treeAdaptor createTree:SUBTEMPLATE FromToken:lc Text:@"SUBTEMPLATE"] retain]
                 old:root_1];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:148:46: ( ^( ARGS $ids) )*
                while ( [stream_ids hasNext] ) {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:148:46: ^( ARGS $ids)
                    {
                        CommonTree *root_2 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_2 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:ARGS Text:@"ARGS"] retain]
                         old:root_2];

                        [treeAdaptor addChild:[stream_ids nextNode] toTree:root_2];

                        [treeAdaptor addChild:root_2 toTree:root_1];
                    }

                }
                [stream_ids reset];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:148:60: ( template )?
                if ( [stream_template hasNext] ) {
                	[treeAdaptor addChild:[stream_template nextTree] toTree:root_1];

                }
                [stream_template reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [list_ids release];
        [retval setStop:[input LT:-1]];


        [stream_LCURLY release];
        [stream_PIPE release];
        [stream_ID release];
        [stream_COMMA release];
        [stream_INDENT release];
        [stream_RCURLY release];
        [stream_template release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end subtemplate */

/*
 * $ANTLR start ifstat
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:151:1: ifstat : (i= INDENT )? LDELIM 'if' '(' c1= conditional ')' RDELIM t1= template ( ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template )* ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? ( INDENT )? endif= LDELIM 'endif' RDELIM ({...}? => NEWLINE )? -> {indent!=nil}? ^( INDENTED_EXPR $i ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ) -> ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ;
 */
- (STParser_ifstat_return *) ifstat
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_ifstat_return * retval = [STParser_ifstat_return newSTParser_ifstat_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    STToken *indent = nil;
    @try {
        /* AST ruleLabelDefs */
        STToken *i = nil;
        STToken *endif = nil;
        STToken *LDELIM36 = nil;
        STToken *string_literal37 = nil;
        STToken *char_literal38 = nil;
        STToken *char_literal39 = nil;
        STToken *RDELIM40 = nil;
        STToken *INDENT41 = nil;
        STToken *LDELIM42 = nil;
        STToken *string_literal43 = nil;
        STToken *char_literal44 = nil;
        STToken *char_literal45 = nil;
        STToken *RDELIM46 = nil;
        STToken *INDENT47 = nil;
        STToken *LDELIM48 = nil;
        STToken *string_literal49 = nil;
        STToken *RDELIM50 = nil;
        STToken *INDENT51 = nil;
        STToken *string_literal52 = nil;
        STToken *RDELIM53 = nil;
        STToken *NEWLINE54 = nil;
        AMutableArray *list_c2 = nil;
        AMutableArray *list_t2 = nil;
         STParser_conditional_return * c1 = nil ;
         
         STParser_template_return * t1 = nil ;
         
         STParser_template_return * t3 = nil ;
         
        ParserRuleReturnScope *c2 = nil;
        ParserRuleReturnScope *t2 = nil;
        CommonTree *i_tree=nil;
        CommonTree *endif_tree=nil;
        CommonTree *LDELIM36_tree=nil;
        CommonTree *string_literal37_tree=nil;
        CommonTree *char_literal38_tree=nil;
        CommonTree *char_literal39_tree=nil;
        CommonTree *RDELIM40_tree=nil;
        CommonTree *INDENT41_tree=nil;
        CommonTree *LDELIM42_tree=nil;
        CommonTree *string_literal43_tree=nil;
        CommonTree *char_literal44_tree=nil;
        CommonTree *char_literal45_tree=nil;
        CommonTree *RDELIM46_tree=nil;
        CommonTree *INDENT47_tree=nil;
        CommonTree *LDELIM48_tree=nil;
        CommonTree *string_literal49_tree=nil;
        CommonTree *RDELIM50_tree=nil;
        CommonTree *INDENT51_tree=nil;
        CommonTree *string_literal52_tree=nil;
        CommonTree *RDELIM53_tree=nil;
        CommonTree *NEWLINE54_tree=nil;
        RewriteRuleTokenStream *stream_ENDIF =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ENDIF"] retain];
        RewriteRuleTokenStream *stream_RDELIM =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RDELIM"] retain];
        RewriteRuleTokenStream *stream_RPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        RewriteRuleTokenStream *stream_NEWLINE =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token NEWLINE"] retain];
        RewriteRuleTokenStream *stream_LDELIM =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LDELIM"] retain];
        RewriteRuleTokenStream *stream_INDENT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token INDENT"] retain];
        RewriteRuleTokenStream *stream_LPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        RewriteRuleTokenStream *stream_IF =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token IF"] retain];
        RewriteRuleTokenStream *stream_ELSE =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ELSE"] retain];
        RewriteRuleTokenStream *stream_ELSEIF =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ELSEIF"] retain];
        RewriteRuleSubtreeStream *stream_template =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule template"] retain];
        RewriteRuleSubtreeStream *stream_conditional =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule conditional"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:5: ( (i= INDENT )? LDELIM 'if' '(' c1= conditional ')' RDELIM t1= template ( ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template )* ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? ( INDENT )? endif= LDELIM 'endif' RDELIM ({...}? => NEWLINE )? -> {indent!=nil}? ^( INDENTED_EXPR $i ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ) -> ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:9: (i= INDENT )? LDELIM 'if' '(' c1= conditional ')' RDELIM t1= template ( ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template )* ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? ( INDENT )? endif= LDELIM 'endif' RDELIM ({...}? => NEWLINE )? // alt
        {

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:10: (i= INDENT )? // block
        NSInteger alt13=2;
        NSInteger LA13_0 = [input LA:1];

        if ( (LA13_0==INDENT) ) {
            alt13=1;
        }
        switch (alt13) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:153:10: i= INDENT // alt
                {

                i=(STToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat690];  
                    [stream_INDENT addElement:i];


                }
                break;

        }


        LDELIM36=(STToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat693];  
            [stream_LDELIM addElement:LDELIM36];


        string_literal37=(STToken *)[self match:input TokenType:IF Follow:FOLLOW_IF_in_ifstat695];  
            [stream_IF addElement:string_literal37];


        char_literal38=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_ifstat697];  
            [stream_LPAREN addElement:char_literal38];


        /* ruleRef */
        [self pushFollow:FOLLOW_conditional_in_ifstat701];
        c1 = [self conditional];

        [self popFollow];


        [stream_conditional addElement:[c1 getTree]];

        char_literal39=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_ifstat703];  
            [stream_RPAREN addElement:char_literal39];


        RDELIM40=(STToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat705];  
            [stream_RDELIM addElement:RDELIM40];



        if ([input LA:1]!=NEWLINE) indent=i;


        /* ruleRef */
        [self pushFollow:FOLLOW_template_in_ifstat723];
        t1 = [self template];

        [self popFollow];


        [stream_template addElement:[t1 getTree]];


        do {
            NSInteger alt15=2;
            NSInteger LA15_0 = [input LA:1];
            if ( (LA15_0==INDENT) ) {
                NSInteger LA15_1 = [input LA:2];
                if ( (LA15_1==LDELIM) ) {
                    NSInteger LA15_2 = [input LA:3];
                    if ( (LA15_2==ELSEIF) ) {
                        alt15=1;
                    }


                }


            }
            else if ( (LA15_0==LDELIM) ) {
                NSInteger LA15_2 = [input LA:2];
                if ( (LA15_2==ELSEIF) ) {
                    alt15=1;
                }


            }


            switch (alt15) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:155:15: ( INDENT )? LDELIM 'elseif' '(' c2+= conditional ')' RDELIM t2+= template // alt
                    {

                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:155:15: ( INDENT )? // block
                    NSInteger alt14=2;
                    NSInteger LA14_0 = [input LA:1];

                    if ( (LA14_0==INDENT) ) {
                        alt14=1;
                    }
                    switch (alt14) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:155:15: INDENT // alt
                            {

                            INDENT41=(STToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat739];  
                                [stream_INDENT addElement:INDENT41];


                            }
                            break;

                    }


                    LDELIM42=(STToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat742];  
                        [stream_LDELIM addElement:LDELIM42];


                    string_literal43=(STToken *)[self match:input TokenType:ELSEIF Follow:FOLLOW_ELSEIF_in_ifstat744];  
                        [stream_ELSEIF addElement:string_literal43];


                    char_literal44=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_ifstat746];  
                        [stream_LPAREN addElement:char_literal44];


                    /* ruleRef */
                    [self pushFollow:FOLLOW_conditional_in_ifstat750];
                    c2 = [self conditional];

                    [self popFollow];


                    [stream_conditional addElement:[c2 getTree]];
                    if (list_c2 == nil) list_c2 = [[AMutableArray arrayWithCapacity:5] retain];
                    [list_c2 addObject:[c2 getTree]];


                    char_literal45=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_ifstat752];  
                        [stream_RPAREN addElement:char_literal45];


                    RDELIM46=(STToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat754];  
                        [stream_RDELIM addElement:RDELIM46];


                    /* ruleRef */
                    [self pushFollow:FOLLOW_template_in_ifstat758];
                    t2 = [self template];

                    [self popFollow];


                    [stream_template addElement:[t2 getTree]];
                    if (list_t2 == nil) list_t2 = [[AMutableArray arrayWithCapacity:5] retain];
                    [list_t2 addObject:[t2 getTree]];


                    }
                    break;

                default :
                    goto loop15;
            }
        } while (YES);
        loop15: ;


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:156:13: ( ( INDENT )? LDELIM 'else' RDELIM t3= template )? // block
        NSInteger alt17=2;
        NSInteger LA17_0 = [input LA:1];

        if ( (LA17_0==INDENT) ) {
            NSInteger LA17_1 = [input LA:2];

            if ( (LA17_1==LDELIM) ) {
                NSInteger LA17_2 = [input LA:3];

                if ( (LA17_2==ELSE) ) {
                    alt17=1;
                }
            }
        }
        else if ( (LA17_0==LDELIM) ) {
            NSInteger LA17_2 = [input LA:2];

            if ( (LA17_2==ELSE) ) {
                alt17=1;
            }
        }
        switch (alt17) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:156:15: ( INDENT )? LDELIM 'else' RDELIM t3= template // alt
                {

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:156:15: ( INDENT )? // block
                NSInteger alt16=2;
                NSInteger LA16_0 = [input LA:1];

                if ( (LA16_0==INDENT) ) {
                    alt16=1;
                }
                switch (alt16) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:156:15: INDENT // alt
                        {

                        INDENT47=(STToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat777];  
                            [stream_INDENT addElement:INDENT47];


                        }
                        break;

                }


                LDELIM48=(STToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat780];  
                    [stream_LDELIM addElement:LDELIM48];


                string_literal49=(STToken *)[self match:input TokenType:ELSE Follow:FOLLOW_ELSE_in_ifstat782];  
                    [stream_ELSE addElement:string_literal49];


                RDELIM50=(STToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat784];  
                    [stream_RDELIM addElement:RDELIM50];


                /* ruleRef */
                [self pushFollow:FOLLOW_template_in_ifstat788];
                t3 = [self template];

                [self popFollow];


                [stream_template addElement:[t3 getTree]];

                }
                break;

        }


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:157:13: ( INDENT )? // block
        NSInteger alt18=2;
        NSInteger LA18_0 = [input LA:1];

        if ( (LA18_0==INDENT) ) {
            alt18=1;
        }
        switch (alt18) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:157:13: INDENT // alt
                {

                INDENT51=(STToken *)[self match:input TokenType:INDENT Follow:FOLLOW_INDENT_in_ifstat805];  
                    [stream_INDENT addElement:INDENT51];


                }
                break;

        }


        endif=(STToken *)[self match:input TokenType:LDELIM Follow:FOLLOW_LDELIM_in_ifstat811];  
            [stream_LDELIM addElement:endif];


        string_literal52=(STToken *)[self match:input TokenType:ENDIF Follow:FOLLOW_ENDIF_in_ifstat813];  
            [stream_ENDIF addElement:string_literal52];


        RDELIM53=(STToken *)[self match:input TokenType:RDELIM Follow:FOLLOW_RDELIM_in_ifstat823];  
            [stream_RDELIM addElement:RDELIM53];


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:160:9: ({...}? => NEWLINE )? // block
        NSInteger alt19=2;
        NSInteger LA19_0 = [input LA:1];

        if ( (LA19_0==NEWLINE) ) {
            NSInteger LA19_1 = [input LA:2];

            if ( (( ((STToken *)retval.start).line != [input LT:1].line )) ) {
                alt19=1;
            }
        }
        switch (alt19) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:160:10: {...}? => NEWLINE // alt
                {
                if ( !(((STToken *)retval.start).line != ((STToken *)[input LT:1]).line) ) {
                    @throw [FailedPredicateException newException:@"ifstat" predicate:@" $ifstat.start.line] != [input LT:1].line " stream:input];
                }

                NEWLINE54=(STToken *)[self match:input TokenType:NEWLINE Follow:FOLLOW_NEWLINE_in_ifstat846];  
                    [stream_NEWLINE addElement:NEWLINE54];


                }
                break;

        }


        // AST REWRITE
        // elements: t2, c1, t3, IF, t3, c2, ELSE, ELSEIF, c2, t2, IF, i, t1, ELSEIF, ELSE, t1, c1
        // token labels: i
        // rule labels: t3, retval, t1, c1
        // token list labels: 
        // rule list labels: t2, c2
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleTokenStream *stream_i =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor description:@"token i" element:i] retain];
        RewriteRuleSubtreeStream *stream_t3 =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token t3" element:t3!=nil?[t3 getTree]:nil] retain];
        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];
        RewriteRuleSubtreeStream *stream_t1 =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token t1" element:t1!=nil?[t1 getTree]:nil] retain];
        RewriteRuleSubtreeStream *stream_c1 =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token c1" element:c1!=nil?[c1 getTree]:nil] retain];
        RewriteRuleSubtreeStream *stream_t2 =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token t2" elements:list_t2] retain];
        RewriteRuleSubtreeStream *stream_c2 =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token c2" elements:list_c2] retain];
        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 161:9: -> {indent!=nil}? ^( INDENTED_EXPR $i ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) )
        if (indent!=nil) {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:162:12: ^( INDENTED_EXPR $i ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? ) )
            {
                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                        [[treeAdaptor createTree:INDENTED_EXPR Text:@"INDENTED_EXPR"] retain]
                 old:root_1];

                [treeAdaptor addChild:[stream_i nextNode] toTree:root_1];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:162:31: ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? )
                {
                    CommonTree *root_2 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                    root_2 = (CommonTree *)[treeAdaptor becomeRoot:
                                [stream_IF nextNode]
                     old:root_2];

                    [treeAdaptor addChild:[stream_c1 nextTree] toTree:root_2];

                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:162:43: ( $t1)?
                    if ( [stream_t1 hasNext] ) {
                    	[treeAdaptor addChild:[stream_t1 nextTree] toTree:root_2];

                    }
                    [stream_t1 reset];

                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:162:47: ( ^( 'elseif' $c2 $t2) )*
                    while ( [stream_t2 hasNext]||[stream_c2 hasNext]||[stream_ELSEIF hasNext] ) {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:162:47: ^( 'elseif' $c2 $t2)
                        {
                            CommonTree *root_3 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_3 = (CommonTree *)[treeAdaptor becomeRoot:
                                        [stream_ELSEIF nextNode]
                             old:root_3];

                            [treeAdaptor addChild:[stream_c2 nextTree] toTree:root_3];

                            [treeAdaptor addChild:[stream_t2 nextTree] toTree:root_3];

                            [treeAdaptor addChild:root_3 toTree:root_2];
                        }

                    }
                    [stream_t2 reset];
                    [stream_c2 reset];
                    [stream_ELSEIF reset];

                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:162:68: ( ^( 'else' ( $t3)? ) )?
                    if ( [stream_ELSE hasNext]||[stream_t3 hasNext] ) {
                    	// /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:162:68: ^( 'else' ( $t3)? )
                    	{
                    	    CommonTree *root_3 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                    	    root_3 = (CommonTree *)[treeAdaptor becomeRoot:
                    	                [stream_ELSE nextNode]
                    	     old:root_3];

                    	    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:162:78: ( $t3)?
                    	    if ( [stream_t3 hasNext] ) {
                    	    	[treeAdaptor addChild:[stream_t3 nextTree] toTree:root_3];

                    	    }
                    	    [stream_t3 reset];

                    	    [treeAdaptor addChild:root_3 toTree:root_2];
                    	}

                    }
                    [stream_ELSE reset];
                    [stream_t3 reset];

                    [treeAdaptor addChild:root_2 toTree:root_1];
                }

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }

        else // 163:9: -> ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:163:31: ^( 'if' $c1 ( $t1)? ( ^( 'elseif' $c2 $t2) )* ( ^( 'else' ( $t3)? ) )? )
            {
                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                            [stream_IF nextNode]
                 old:root_1];

                [treeAdaptor addChild:[stream_c1 nextTree] toTree:root_1];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:163:43: ( $t1)?
                if ( [stream_t1 hasNext] ) {
                	[treeAdaptor addChild:[stream_t1 nextTree] toTree:root_1];

                }
                [stream_t1 reset];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:163:47: ( ^( 'elseif' $c2 $t2) )*
                while ( [stream_c2 hasNext]||[stream_t2 hasNext]||[stream_ELSEIF hasNext] ) {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:163:47: ^( 'elseif' $c2 $t2)
                    {
                        CommonTree *root_2 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_2 = (CommonTree *)[treeAdaptor becomeRoot:
                                    [stream_ELSEIF nextNode]
                         old:root_2];

                        [treeAdaptor addChild:[stream_c2 nextTree] toTree:root_2];

                        [treeAdaptor addChild:[stream_t2 nextTree] toTree:root_2];

                        [treeAdaptor addChild:root_2 toTree:root_1];
                    }

                }
                [stream_c2 reset];
                [stream_t2 reset];
                [stream_ELSEIF reset];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:163:68: ( ^( 'else' ( $t3)? ) )?
                if ( [stream_ELSE hasNext]||[stream_t3 hasNext] ) {
                	// /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:163:68: ^( 'else' ( $t3)? )
                	{
                	    CommonTree *root_2 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                	    root_2 = (CommonTree *)[treeAdaptor becomeRoot:
                	                [stream_ELSE nextNode]
                	     old:root_2];

                	    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:163:78: ( $t3)?
                	    if ( [stream_t3 hasNext] ) {
                	    	[treeAdaptor addChild:[stream_t3 nextTree] toTree:root_2];

                	    }
                	    [stream_t3 reset];

                	    [treeAdaptor addChild:root_2 toTree:root_1];
                	}

                }
                [stream_ELSE reset];
                [stream_t3 reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [list_c2 release];
        [list_t2 release];
        [retval setStop:[input LT:-1]];


        [stream_ENDIF release];
        [stream_RDELIM release];
        [stream_RPAREN release];
        [stream_NEWLINE release];
        [stream_LDELIM release];
        [stream_INDENT release];
        [stream_LPAREN release];
        [stream_IF release];
        [stream_ELSE release];
        [stream_ELSEIF release];
        [stream_template release];
        [stream_conditional release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end ifstat */

/*
 * $ANTLR start conditional
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:166:1: conditional : andConditional ( '||' ^ andConditional )* ;
 */
- (STParser_conditional_return *) conditional
{
    /* ruleScopeSetUp */
    [conditional_stack push:[[conditional_Scope newconditional_Scope] retain]];
    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_conditional_return * retval = [STParser_conditional_return newSTParser_conditional_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *string_literal56 = nil;
         STParser_andConditional_return * andConditional55 = nil ;
         
         STParser_andConditional_return * andConditional57 = nil ;
         

        CommonTree *string_literal56_tree=nil;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:170:5: ( andConditional ( '||' ^ andConditional )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:170:7: andConditional ( '||' ^ andConditional )* // alt
        {
        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_andConditional_in_conditional990];
        andConditional55 = [self andConditional];

        [self popFollow];


        [treeAdaptor addChild:[andConditional55 getTree] toTree:root_0];


        do {
            NSInteger alt20=2;
            NSInteger LA20_0 = [input LA:1];
            if ( (LA20_0==OR) ) {
                alt20=1;
            }


            switch (alt20) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:170:24: '||' ^ andConditional // alt
                    {

                    string_literal56=(STToken *)[self match:input TokenType:OR Follow:FOLLOW_OR_in_conditional994]; 
                    string_literal56_tree = /* ASTParser createNodeFromToken */
                    (CommonTree *)[[treeAdaptor create:string_literal56] retain]
                    ;
                    root_0 = (CommonTree *)[treeAdaptor becomeRoot:string_literal56_tree old:root_0];


                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_andConditional_in_conditional997];
                    andConditional57 = [self andConditional];

                    [self popFollow];


                    [treeAdaptor addChild:[andConditional57 getTree] toTree:root_0];

                    }
                    break;

                default :
                    goto loop20;
            }
        } while (YES);
        loop20: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */
        [conditional_stack pop];
    }
    return retval;
}
/* $ANTLR end conditional */

/*
 * $ANTLR start andConditional
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:173:1: andConditional : notConditional ( '&&' ^ notConditional )* ;
 */
- (STParser_andConditional_return *) andConditional
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_andConditional_return * retval = [STParser_andConditional_return newSTParser_andConditional_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *string_literal59 = nil;
         STParser_notConditional_return * notConditional58 = nil ;
         
         STParser_notConditional_return * notConditional60 = nil ;
         

        CommonTree *string_literal59_tree=nil;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:173:16: ( notConditional ( '&&' ^ notConditional )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:173:18: notConditional ( '&&' ^ notConditional )* // alt
        {
        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_notConditional_in_andConditional1013];
        notConditional58 = [self notConditional];

        [self popFollow];


        [treeAdaptor addChild:[notConditional58 getTree] toTree:root_0];


        do {
            NSInteger alt21=2;
            NSInteger LA21_0 = [input LA:1];
            if ( (LA21_0==AND) ) {
                alt21=1;
            }


            switch (alt21) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:173:35: '&&' ^ notConditional // alt
                    {

                    string_literal59=(STToken *)[self match:input TokenType:AND Follow:FOLLOW_AND_in_andConditional1017]; 
                    string_literal59_tree = /* ASTParser createNodeFromToken */
                    (CommonTree *)[[treeAdaptor create:string_literal59] retain]
                    ;
                    root_0 = (CommonTree *)[treeAdaptor becomeRoot:string_literal59_tree old:root_0];


                    /* ASTParser ruleRef */
                    /* ruleRef */
                    [self pushFollow:FOLLOW_notConditional_in_andConditional1020];
                    notConditional60 = [self notConditional];

                    [self popFollow];


                    [treeAdaptor addChild:[notConditional60 getTree] toTree:root_0];

                    }
                    break;

                default :
                    goto loop21;
            }
        } while (YES);
        loop21: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end andConditional */

/*
 * $ANTLR start notConditional
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:175:1: notConditional : ( '!' ^ notConditional | memberExpr );
 */
- (STParser_notConditional_return *) notConditional
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_notConditional_return * retval = [STParser_notConditional_return newSTParser_notConditional_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *char_literal61 = nil;
         STParser_notConditional_return * notConditional62 = nil ;
         
         STParser_memberExpr_return * memberExpr63 = nil ;
         

        CommonTree *char_literal61_tree=nil;

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:176:5: ( '!' ^ notConditional | memberExpr ) //ruleblock
        NSInteger alt22=2;
        NSInteger LA22_0 = [input LA:1];

        if ( (LA22_0==BANG) ) {
            alt22=1;
        }
        else if ( (LA22_0==ID||LA22_0==STRING||(LA22_0 >= T_FALSE && LA22_0 <= T_TRUE)||LA22_0==SUPER||LA22_0==LBRACK||LA22_0==LCURLY||LA22_0==AT) ) {
            alt22=2;
        }
        else if ( (LA22_0==LPAREN) && ((([conditional_stack size]>0)||([conditional_stack size]==0)))) {
            alt22=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:22 state:0 stream:input];
            nvae.c = LA22_0;
            @throw nvae;

        }
        switch (alt22) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:176:9: '!' ^ notConditional // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                char_literal61=(STToken *)[self match:input TokenType:BANG Follow:FOLLOW_BANG_in_notConditional1038]; 
                char_literal61_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[[treeAdaptor create:char_literal61] retain]
                ;
                root_0 = (CommonTree *)[treeAdaptor becomeRoot:char_literal61_tree old:root_0];


                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_notConditional_in_notConditional1041];
                notConditional62 = [self notConditional];

                [self popFollow];


                [treeAdaptor addChild:[notConditional62 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:177:9: memberExpr // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_memberExpr_in_notConditional1051];
                memberExpr63 = [self memberExpr];

                [self popFollow];


                [treeAdaptor addChild:[memberExpr63 getTree] toTree:root_0];

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end notConditional */

/*
 * $ANTLR start notConditionalExpr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:180:1: notConditionalExpr : ( ID -> ID ) (p= '.' prop= ID -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr ) )* ;
 */
- (STParser_notConditionalExpr_return *) notConditionalExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_notConditionalExpr_return * retval = [STParser_notConditionalExpr_return newSTParser_notConditionalExpr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *p = nil;
        STToken *prop = nil;
        STToken *ID64 = nil;
        STToken *char_literal65 = nil;
        STToken *char_literal67 = nil;
         STParser_mapExpr_return * mapExpr66 = nil ;
         

        CommonTree *p_tree=nil;
        CommonTree *prop_tree=nil;
        CommonTree *ID64_tree=nil;
        CommonTree *char_literal65_tree=nil;
        CommonTree *char_literal67_tree=nil;
        RewriteRuleTokenStream *stream_RPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        RewriteRuleTokenStream *stream_DOT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token DOT"] retain];
        RewriteRuleTokenStream *stream_ID =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        RewriteRuleTokenStream *stream_LPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        RewriteRuleSubtreeStream *stream_mapExpr =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapExpr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:181:5: ( ( ID -> ID ) (p= '.' prop= ID -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr ) )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:181:9: ( ID -> ID ) (p= '.' prop= ID -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr ) )* // alt
        {

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:181:9: ( ID -> ID ) // blockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:181:10: ID // alt
        {

        ID64=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_notConditionalExpr1071];  
            [stream_ID addElement:ID64];


        // AST REWRITE
        // elements: ID
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 181:12: -> ID
        {
             // TODO: args: 
            [treeAdaptor addChild:
                        [stream_ID nextNode]
             toTree:root_0];

        }


        retval.tree = root_0;


        }



        do {
            NSInteger alt23=3;
            NSInteger LA23_0 = [input LA:1];
            if ( (LA23_0==DOT) ) {
                NSInteger LA23_2 = [input LA:2];
                if ( (LA23_2==ID) ) {
                    alt23=1;
                }
                else if ( (LA23_2==LPAREN) ) {
                    alt23=2;
                }


            }


            switch (alt23) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:182:13: p= '.' prop= ID // alt
                    {

                    p=(STToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_notConditionalExpr1090];  
                        [stream_DOT addElement:p];


                    prop=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_notConditionalExpr1094];  
                        [stream_ID addElement:prop];


                    // AST REWRITE
                    // elements: prop, notConditionalExpr
                    // token labels: prop
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleTokenStream *stream_prop =
                        [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor description:@"token prop" element:prop] retain];
                    RewriteRuleSubtreeStream *stream_retval =
                        [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                    root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 182:49: -> ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop)
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:182:52: ^( PROP[$p,@\"PROP\"] $notConditionalExpr $prop)
                        {
                            CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                    [[treeAdaptor createTree:PROP FromToken:p Text:@"PROP"] retain]
                             old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                            [treeAdaptor addChild:[stream_prop nextNode] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:183:13: p= '.' '(' mapExpr ')' // alt
                    {

                    p=(STToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_notConditionalExpr1145];  
                        [stream_DOT addElement:p];


                    char_literal65=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_notConditionalExpr1147];  
                        [stream_LPAREN addElement:char_literal65];


                    /* ruleRef */
                    [self pushFollow:FOLLOW_mapExpr_in_notConditionalExpr1149];
                    mapExpr66 = [self mapExpr];

                    [self popFollow];


                    [stream_mapExpr addElement:[mapExpr66 getTree]];

                    char_literal67=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_notConditionalExpr1151];  
                        [stream_RPAREN addElement:char_literal67];


                    // AST REWRITE
                    // elements: notConditionalExpr, mapExpr
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleSubtreeStream *stream_retval =
                        [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                    root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 183:49: -> ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr )
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:183:52: ^( PROP_IND[$p,@\"PROP_IND\"] $notConditionalExpr mapExpr )
                        {
                            CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                    [[treeAdaptor createTree:PROP_IND FromToken:p Text:@"PROP_IND"] retain]
                             old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                            [treeAdaptor addChild:[stream_mapExpr nextTree] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;

                default :
                    goto loop23;
            }
        } while (YES);
        loop23: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_RPAREN release];
        [stream_DOT release];
        [stream_ID release];
        [stream_LPAREN release];
        [stream_mapExpr release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end notConditionalExpr */

/*
 * $ANTLR start exprOptions
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:187:1: exprOptions : option ( ',' option )* -> ^( OPTIONS ( option )* ) ;
 */
- (STParser_exprOptions_return *) exprOptions
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_exprOptions_return * retval = [STParser_exprOptions_return newSTParser_exprOptions_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *char_literal69 = nil;
         STParser_option_return * option68 = nil ;
         
         STParser_option_return * option70 = nil ;
         

        CommonTree *char_literal69_tree=nil;
        RewriteRuleTokenStream *stream_COMMA =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        RewriteRuleSubtreeStream *stream_option =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule option"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:187:13: ( option ( ',' option )* -> ^( OPTIONS ( option )* ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:187:15: option ( ',' option )* // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_option_in_exprOptions1201];
        option68 = [self option];

        [self popFollow];


        [stream_option addElement:[option68 getTree]];


        do {
            NSInteger alt24=2;
            NSInteger LA24_0 = [input LA:1];
            if ( (LA24_0==COMMA) ) {
                alt24=1;
            }


            switch (alt24) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:187:24: ',' option // alt
                    {

                    char_literal69=(STToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_exprOptions1205];  
                        [stream_COMMA addElement:char_literal69];


                    /* ruleRef */
                    [self pushFollow:FOLLOW_option_in_exprOptions1207];
                    option70 = [self option];

                    [self popFollow];


                    [stream_option addElement:[option70 getTree]];

                    }
                    break;

                default :
                    goto loop24;
            }
        } while (YES);
        loop24: ;


        // AST REWRITE
        // elements: option
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 187:38: -> ^( OPTIONS ( option )* )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:187:41: ^( OPTIONS ( option )* )
            {
                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                        [[treeAdaptor createTree:OPTIONS Text:@"OPTIONS"] retain]
                 old:root_1];

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:187:51: ( option )*
                while ( [stream_option hasNext] ) {
                    [treeAdaptor addChild:[stream_option nextTree] toTree:root_1];

                }
                [stream_option reset];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_COMMA release];
        [stream_option release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end exprOptions */

/*
 * $ANTLR start option
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:189:1: option : ID ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) ->| -> {validOption&&defVal!=nil}? ^( EQUALS[EQUALS, @\"=\"] ID STRING[$ID, defVal] ) ->) ;
 */
- (STParser_option_return *) option
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_option_return * retval = [STParser_option_return newSTParser_option_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;


        NSString *IDstr = [input LT:1].text;
        NSString *defVal = [[Compiler defaultOptionValues] objectForKey:IDstr];
        BOOL validOption = ([[Compiler getSupportedOptions] objectForKey:IDstr] != nil);

    @try {
        /* AST ruleLabelDefs */
        STToken *ID71 = nil;
        STToken *char_literal72 = nil;
         STParser_exprNoComma_return * exprNoComma73 = nil ;
         

        CommonTree *ID71_tree=nil;
        CommonTree *char_literal72_tree=nil;
        RewriteRuleTokenStream *stream_EQUALS =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token EQUALS"] retain];
        RewriteRuleTokenStream *stream_ID =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        RewriteRuleSubtreeStream *stream_exprNoComma =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule exprNoComma"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:195:5: ( ID ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) ->| -> {validOption&&defVal!=nil}? ^( EQUALS[EQUALS, @\"=\"] ID STRING[$ID, defVal] ) ->) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:195:9: ID ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) ->| -> {validOption&&defVal!=nil}? ^( EQUALS[EQUALS, @\"=\"] ID STRING[$ID, defVal] ) ->) // alt
        {

        ID71=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_option1239];  
            [stream_ID addElement:ID71];




                if ( !validOption ) {
                    [errMgr compileTimeError:NO_SUCH_OPTION templateToken:templateToken t:ID71 arg:(ID71!=nil?ID71.text:nil)];
                }
                


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:201:9: ( '=' exprNoComma -> {validOption}? ^( '=' ID exprNoComma ) ->| -> {validOption&&defVal!=nil}? ^( EQUALS[EQUALS, @\"=\"] ID STRING[$ID, defVal] ) ->) // block
        NSInteger alt25=2;
        NSInteger LA25_0 = [input LA:1];

        if ( (LA25_0==EQUALS) ) {
            alt25=1;
        }
        else if ( (LA25_0==COMMA||LA25_0==RDELIM) ) {
            alt25=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:25 state:0 stream:input];
            nvae.c = LA25_0;
            @throw nvae;

        }
        switch (alt25) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:201:13: '=' exprNoComma // alt
                {

                char_literal72=(STToken *)[self match:input TokenType:EQUALS Follow:FOLLOW_EQUALS_in_option1263];  
                    [stream_EQUALS addElement:char_literal72];


                /* ruleRef */
                [self pushFollow:FOLLOW_exprNoComma_in_option1265];
                exprNoComma73 = [self exprNoComma];

                [self popFollow];


                [stream_exprNoComma addElement:[exprNoComma73 getTree]];

                // AST REWRITE
                // elements: ID, EQUALS, exprNoComma
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 201:49: -> {validOption}? ^( '=' ID exprNoComma )
                if (validOption) {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:201:67: ^( '=' ID exprNoComma )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                    [stream_EQUALS nextNode]
                         old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:
                                    [stream_ID nextNode]
                         toTree:root_1];

                        [treeAdaptor addChild:[stream_exprNoComma nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                else // 202:49: ->
                {
                    root_0 = nil;
                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:203:13:  // alt
                {



                            if ( defVal==nil ) {
                                [errMgr compileTimeError:NO_DEFAULT_VALUE templateToken:templateToken t:ID71  arg:ID71];
                            }
                            


                // AST REWRITE
                // elements: ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 208:49: -> {validOption&&defVal!=nil}? ^( EQUALS[EQUALS, @\"=\"] ID STRING[$ID, defVal] )
                if (validOption&&defVal!=nil) {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:209:52: ^( EQUALS[EQUALS, @\"=\"] ID STRING[$ID, defVal] )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:EQUALS Text:@"="] retain]
                         old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:
                                    [stream_ID nextNode]
                         toTree:root_1];

                        [treeAdaptor addChild:
                                [[treeAdaptor createTree:STRING FromToken:ID71 Text:defVal] retain]
                         toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }

                else // 210:49: ->
                {
                    root_0 = nil;
                }


                retval.tree = root_0;


                }
                break;

        }


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_EQUALS release];
        [stream_ID release];
        [stream_exprNoComma release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end option */

/*
 * $ANTLR start exprNoComma
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:214:1: exprNoComma : memberExpr ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) ;
 */
- (STParser_exprNoComma_return *) exprNoComma
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_exprNoComma_return * retval = [STParser_exprNoComma_return newSTParser_exprNoComma_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *char_literal75 = nil;
         STParser_memberExpr_return * memberExpr74 = nil ;
         
         STParser_mapTemplateRef_return * mapTemplateRef76 = nil ;
         

        CommonTree *char_literal75_tree=nil;
        RewriteRuleTokenStream *stream_COLON =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COLON"] retain];
        RewriteRuleSubtreeStream *stream_memberExpr =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule memberExpr"] retain];
        RewriteRuleSubtreeStream *stream_mapTemplateRef =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapTemplateRef"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:215:5: ( memberExpr ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:215:9: memberExpr ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_memberExpr_in_exprNoComma1553];
        memberExpr74 = [self memberExpr];

        [self popFollow];


        [stream_memberExpr addElement:[memberExpr74 getTree]];

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:216:9: ( ':' mapTemplateRef -> ^( MAP memberExpr mapTemplateRef ) | -> memberExpr ) // block
        NSInteger alt26=2;
        NSInteger LA26_0 = [input LA:1];

        if ( (LA26_0==COLON) ) {
            alt26=1;
        }
        else if ( (LA26_0==RPAREN||(LA26_0 >= RBRACK && LA26_0 <= COMMA)||LA26_0==RDELIM) ) {
            alt26=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:26 state:0 stream:input];
            nvae.c = LA26_0;
            @throw nvae;

        }
        switch (alt26) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:216:11: ':' mapTemplateRef // alt
                {

                char_literal75=(STToken *)[self match:input TokenType:COLON Follow:FOLLOW_COLON_in_exprNoComma1565];  
                    [stream_COLON addElement:char_literal75];


                /* ruleRef */
                [self pushFollow:FOLLOW_mapTemplateRef_in_exprNoComma1567];
                mapTemplateRef76 = [self mapTemplateRef];

                [self popFollow];


                [stream_mapTemplateRef addElement:[mapTemplateRef76 getTree]];

                // AST REWRITE
                // elements: mapTemplateRef, memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 216:49: -> ^( MAP memberExpr mapTemplateRef )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:216:52: ^( MAP memberExpr mapTemplateRef )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:MAP Text:@"MAP"] retain]
                         old:root_1];

                        [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_1];

                        [treeAdaptor addChild:[stream_mapTemplateRef nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:217:49:  // alt
                {
                // AST REWRITE
                // elements: memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 217:49: -> memberExpr
                {
                    [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_0];

                }


                retval.tree = root_0;


                }
                break;

        }


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_COLON release];
        [stream_memberExpr release];
        [stream_mapTemplateRef release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end exprNoComma */

/*
 * $ANTLR start expr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:221:1: expr : mapExpr ;
 */
- (STParser_expr_return *) expr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_expr_return * retval = [STParser_expr_return newSTParser_expr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
         STParser_mapExpr_return * mapExpr77 = nil ;
         


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:221:6: ( mapExpr ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:221:8: mapExpr // alt
        {
        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_mapExpr_in_expr1671];
        mapExpr77 = [self mapExpr];

        [self popFollow];


        [treeAdaptor addChild:[mapExpr77 getTree] toTree:root_0];

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end expr */

/*
 * $ANTLR start mapExpr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:225:1: mapExpr : memberExpr ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) (col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* -> ^( MAP[$col] $mapExpr ( $x)+ ) )* ;
 */
- (STParser_mapExpr_return *) mapExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_mapExpr_return * retval = [STParser_mapExpr_return newSTParser_mapExpr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *c = nil;
        STToken *col = nil;
        STToken *char_literal81 = nil;
        AMutableArray *list_x = nil;
         STParser_memberExpr_return * memberExpr78 = nil ;
         
         STParser_memberExpr_return * memberExpr79 = nil ;
         
         STParser_mapTemplateRef_return * mapTemplateRef80 = nil ;
         
        ParserRuleReturnScope *x = nil;
        CommonTree *c_tree=nil;
        CommonTree *col_tree=nil;
        CommonTree *char_literal81_tree=nil;
        RewriteRuleTokenStream *stream_COLON =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COLON"] retain];
        RewriteRuleTokenStream *stream_COMMA =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        RewriteRuleSubtreeStream *stream_memberExpr =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule memberExpr"] retain];
        RewriteRuleSubtreeStream *stream_mapTemplateRef =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapTemplateRef"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:226:5: ( memberExpr ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) (col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* -> ^( MAP[$col] $mapExpr ( $x)+ ) )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:226:9: memberExpr ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) (col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* -> ^( MAP[$col] $mapExpr ( $x)+ ) )* // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_memberExpr_in_mapExpr1688];
        memberExpr78 = [self memberExpr];

        [self popFollow];


        [stream_memberExpr addElement:[memberExpr78 getTree]];

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:227:9: ( (c= ',' memberExpr )+ col= ':' mapTemplateRef -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef ) | -> memberExpr ) // block
        NSInteger alt28=2;
        NSInteger LA28_0 = [input LA:1];

        if ( (LA28_0==COMMA) ) {
            alt28=1;
        }
        else if ( (LA28_0==SEMI||LA28_0==COLON||LA28_0==RPAREN||LA28_0==RDELIM) ) {
            alt28=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:28 state:0 stream:input];
            nvae.c = LA28_0;
            @throw nvae;

        }
        switch (alt28) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:227:11: (c= ',' memberExpr )+ col= ':' mapTemplateRef // alt
                {

                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:227:11: (c= ',' memberExpr )+ // positiveClosureBlock
                NSInteger cnt27 = 0;
                do {
                    NSInteger alt27 = 2;
                    NSInteger LA27_0 = [input LA:1];
                    if ( (LA27_0==COMMA) ) {
                        alt27=1;
                    }


                    switch (alt27) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:227:12: c= ',' memberExpr // alt
                            {

                            c=(STToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_mapExpr1703];  
                                [stream_COMMA addElement:c];


                            /* ruleRef */
                            [self pushFollow:FOLLOW_memberExpr_in_mapExpr1705];
                            memberExpr79 = [self memberExpr];

                            [self popFollow];


                            [stream_memberExpr addElement:[memberExpr79 getTree]];

                            }
                            break;

                        default :
                            if ( cnt27 >= 1 )
                                goto loop27;
                            EarlyExitException *eee =
                                [EarlyExitException newException:input decisionNumber:27];
                            @throw eee;
                    }
                    cnt27++;
                } while (YES);
                loop27: ;


                col=(STToken *)[self match:input TokenType:COLON Follow:FOLLOW_COLON_in_mapExpr1711];  
                    [stream_COLON addElement:col];


                /* ruleRef */
                [self pushFollow:FOLLOW_mapTemplateRef_in_mapExpr1713];
                mapTemplateRef80 = [self mapTemplateRef];

                [self popFollow];


                [stream_mapTemplateRef addElement:[mapTemplateRef80 getTree]];

                // AST REWRITE
                // elements: memberExpr, mapTemplateRef
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 228:49: -> ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:228:52: ^( ZIP[$col] ^( ELEMENTS ( memberExpr )+ ) mapTemplateRef )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:ZIP FromToken:col Text:@"ZIP"] retain]
                         old:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:228:64: ^( ELEMENTS ( memberExpr )+ )
                        {
                            CommonTree *root_2 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_2 = (CommonTree *)[treeAdaptor becomeRoot:
                                    [[treeAdaptor createTree:ELEMENTS Text:@"ELEMENTS"] retain]
                             old:root_2];

                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:228:75: ( memberExpr )+
                            {
                            if ( !([stream_memberExpr hasNext]) ) {
                                @throw [RewriteEarlyExitException newException];
                            }
                            while ( [stream_memberExpr hasNext] ) {
                                [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_2];

                            }
                            [stream_memberExpr reset];

                            }
                            [treeAdaptor addChild:root_2 toTree:root_1];
                        }

                        [treeAdaptor addChild:[stream_mapTemplateRef nextTree] toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:229:49:  // alt
                {
                // AST REWRITE
                // elements: memberExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 229:49: -> memberExpr
                {
                    [treeAdaptor addChild:[stream_memberExpr nextTree] toTree:root_0];

                }


                retval.tree = root_0;


                }
                break;

        }



        do {
            NSInteger alt30=2;
            NSInteger LA30_0 = [input LA:1];
            if ( (LA30_0==COLON) ) {
                alt30=1;
            }


            switch (alt30) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:231:13: col= ':' x+= mapTemplateRef ({...}? => ',' x+= mapTemplateRef )* // alt
                    {


                    if (list_x != nil) [list_x removeAllObjects];


                    col=(STToken *)[self match:input TokenType:COLON Follow:FOLLOW_COLON_in_mapExpr1870];  
                        [stream_COLON addElement:col];


                    /* ruleRef */
                    [self pushFollow:FOLLOW_mapTemplateRef_in_mapExpr1874];
                    x = [self mapTemplateRef];

                    [self popFollow];


                    [stream_mapTemplateRef addElement:[x getTree]];
                    if (list_x == nil) list_x = [[AMutableArray arrayWithCapacity:5] retain];
                    [list_x addObject:[x getTree]];



                    do {
                        NSInteger alt29=2;
                        NSInteger LA29_0 = [input LA:1];
                        if ( (LA29_0==COMMA) && ((c==nil))) {
                            alt29=1;
                        }


                        switch (alt29) {
                            case 1 : ;
                                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:232:40: {...}? => ',' x+= mapTemplateRef // alt
                                {

                                if ( !((c==nil)) ) {
                                    @throw [FailedPredicateException newException:@"mapExpr" predicate:@"$c==nil" stream:input];
                                }

                                char_literal81=(STToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_mapExpr1880];  
                                    [stream_COMMA addElement:char_literal81];


                                /* ruleRef */
                                [self pushFollow:FOLLOW_mapTemplateRef_in_mapExpr1884];
                                x = [self mapTemplateRef];

                                [self popFollow];


                                [stream_mapTemplateRef addElement:[x getTree]];
                                if (list_x == nil) list_x = [[AMutableArray arrayWithCapacity:5] retain];
                                [list_x addObject:[x getTree]];


                                }
                                break;

                            default :
                                goto loop29;
                        }
                    } while (YES);
                    loop29: ;


                    // AST REWRITE
                    // elements: mapExpr, x
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: x
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleSubtreeStream *stream_retval =
                        [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];
                    RewriteRuleSubtreeStream *stream_x =
                        [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token x" elements:list_x] retain];
                    root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 233:49: -> ^( MAP[$col] $mapExpr ( $x)+ )
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:233:52: ^( MAP[$col] $mapExpr ( $x)+ )
                        {
                            CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                    [[treeAdaptor createTree:MAP FromToken:col Text:@"MAP"] retain]
                             old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:233:74: ( $x)+
                            {
                            if ( !([stream_x hasNext]) ) {
                                @throw [RewriteEarlyExitException newException];
                            }
                            while ( [stream_x hasNext] ) {
                                [treeAdaptor addChild:[stream_x nextTree] toTree:root_1];

                            }
                            [stream_x reset];

                            }
                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;

                default :
                    goto loop30;
            }
        } while (YES);
        loop30: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [list_x release];
        [retval setStop:[input LT:-1]];


        [stream_COLON release];
        [stream_COMMA release];
        [stream_memberExpr release];
        [stream_mapTemplateRef release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end mapExpr */

/*
 * $ANTLR start mapTemplateRef
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:242:1: mapTemplateRef : ( ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | subtemplate |lp= '(' mapExpr rp= ')' '(' ( argExprList )? ')' -> ^( INCLUDE_IND mapExpr ( argExprList )? ) );
 */
- (STParser_mapTemplateRef_return *) mapTemplateRef
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_mapTemplateRef_return * retval = [STParser_mapTemplateRef_return newSTParser_mapTemplateRef_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *lp = nil;
        STToken *rp = nil;
        STToken *ID82 = nil;
        STToken *char_literal83 = nil;
        STToken *char_literal85 = nil;
        STToken *char_literal88 = nil;
        STToken *char_literal90 = nil;
         STParser_args_return * args84 = nil ;
         
         STParser_subtemplate_return * subtemplate86 = nil ;
         
         STParser_mapExpr_return * mapExpr87 = nil ;
         
         STParser_argExprList_return * argExprList89 = nil ;
         

        CommonTree *lp_tree=nil;
        CommonTree *rp_tree=nil;
        CommonTree *ID82_tree=nil;
        CommonTree *char_literal83_tree=nil;
        CommonTree *char_literal85_tree=nil;
        CommonTree *char_literal88_tree=nil;
        CommonTree *char_literal90_tree=nil;
        RewriteRuleTokenStream *stream_RPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        RewriteRuleTokenStream *stream_ID =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        RewriteRuleTokenStream *stream_LPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        RewriteRuleSubtreeStream *stream_argExprList =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule argExprList"] retain];
        RewriteRuleSubtreeStream *stream_args =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule args"] retain];
        RewriteRuleSubtreeStream *stream_mapExpr =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapExpr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:243:5: ( ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | subtemplate |lp= '(' mapExpr rp= ')' '(' ( argExprList )? ')' -> ^( INCLUDE_IND mapExpr ( argExprList )? ) ) //ruleblock
        NSInteger alt32=3;
        unichar charLA32 = [input LA:1];
        switch (charLA32) {
            case ID: ;
                {
                alt32=1;
                }
                break;
            case LCURLY: ;
                {
                alt32=2;
                }
                break;
            case LPAREN: ;
                {
                alt32=3;
                }
                break;

        default: ;
            NoViableAltException *nvae = [NoViableAltException newException:32 state:0 stream:input];
            nvae.c = charLA32;
            @throw nvae;

        }

        switch (alt32) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:243:9: ID '(' args ')' // alt
                {

                ID82=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_mapTemplateRef1981];  
                    [stream_ID addElement:ID82];


                char_literal83=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_mapTemplateRef1983];  
                    [stream_LPAREN addElement:char_literal83];


                /* ruleRef */
                [self pushFollow:FOLLOW_args_in_mapTemplateRef1985];
                args84 = [self args];

                [self popFollow];


                [stream_args addElement:[args84 getTree]];

                char_literal85=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_mapTemplateRef1987];  
                    [stream_RPAREN addElement:char_literal85];


                // AST REWRITE
                // elements: ID, args
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 243:49: -> ^( INCLUDE ID ( args )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:243:52: ^( INCLUDE ID ( args )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:INCLUDE Text:@"INCLUDE"] retain]
                         old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:
                                    [stream_ID nextNode]
                         toTree:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:243:65: ( args )?
                        if ( [stream_args hasNext] ) {
                        	[treeAdaptor addChild:[stream_args nextTree] toTree:root_1];

                        }
                        [stream_args reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:244:9: subtemplate // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_subtemplate_in_mapTemplateRef2032];
                subtemplate86 = [self subtemplate];

                [self popFollow];


                [treeAdaptor addChild:[subtemplate86 getTree] toTree:root_0];

                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:245:9: lp= '(' mapExpr rp= ')' '(' ( argExprList )? ')' // alt
                {

                lp=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_mapTemplateRef2044];  
                    [stream_LPAREN addElement:lp];


                /* ruleRef */
                [self pushFollow:FOLLOW_mapExpr_in_mapTemplateRef2046];
                mapExpr87 = [self mapExpr];

                [self popFollow];


                [stream_mapExpr addElement:[mapExpr87 getTree]];

                rp=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_mapTemplateRef2050];  
                    [stream_RPAREN addElement:rp];


                char_literal88=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_mapTemplateRef2052];  
                    [stream_LPAREN addElement:char_literal88];


                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:245:35: ( argExprList )? // block
                NSInteger alt31=2;
                NSInteger LA31_0 = [input LA:1];

                if ( (LA31_0==ID||LA31_0==STRING||(LA31_0 >= T_FALSE && LA31_0 <= T_TRUE)||LA31_0==SUPER||LA31_0==LBRACK||LA31_0==LCURLY||LA31_0==AT) ) {
                    alt31=1;
                }
                else if ( (LA31_0==LPAREN) && ((([conditional_stack size]>0)||([conditional_stack size]==0)))) {
                    alt31=1;
                }
                switch (alt31) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:245:35: argExprList // alt
                        {

                        /* ruleRef */
                        [self pushFollow:FOLLOW_argExprList_in_mapTemplateRef2054];
                        argExprList89 = [self argExprList];

                        [self popFollow];


                        [stream_argExprList addElement:[argExprList89 getTree]];

                        }
                        break;

                }


                char_literal90=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_mapTemplateRef2057];  
                    [stream_RPAREN addElement:char_literal90];


                // AST REWRITE
                // elements: argExprList, mapExpr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 245:52: -> ^( INCLUDE_IND mapExpr ( argExprList )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:245:55: ^( INCLUDE_IND mapExpr ( argExprList )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:INCLUDE_IND Text:@"INCLUDE_IND"] retain]
                         old:root_1];

                        [treeAdaptor addChild:[stream_mapExpr nextTree] toTree:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:245:77: ( argExprList )?
                        if ( [stream_argExprList hasNext] ) {
                        	[treeAdaptor addChild:[stream_argExprList nextTree] toTree:root_1];

                        }
                        [stream_argExprList reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_RPAREN release];
        [stream_ID release];
        [stream_LPAREN release];
        [stream_argExprList release];
        [stream_args release];
        [stream_mapExpr release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end mapTemplateRef */

/*
 * $ANTLR start memberExpr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:248:1: memberExpr : ( includeExpr -> includeExpr ) (p= '.' ID -> ^( PROP[$p,@\"PROP\"] $memberExpr ID ) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr ) )* ;
 */
- (STParser_memberExpr_return *) memberExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_memberExpr_return * retval = [STParser_memberExpr_return newSTParser_memberExpr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *p = nil;
        STToken *ID92 = nil;
        STToken *char_literal93 = nil;
        STToken *char_literal95 = nil;
         STParser_includeExpr_return * includeExpr91 = nil ;
         
         STParser_mapExpr_return * mapExpr94 = nil ;
         

        CommonTree *p_tree=nil;
        CommonTree *ID92_tree=nil;
        CommonTree *char_literal93_tree=nil;
        CommonTree *char_literal95_tree=nil;
        RewriteRuleTokenStream *stream_RPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        RewriteRuleTokenStream *stream_DOT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token DOT"] retain];
        RewriteRuleTokenStream *stream_ID =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        RewriteRuleTokenStream *stream_LPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        RewriteRuleSubtreeStream *stream_includeExpr =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule includeExpr"] retain];
        RewriteRuleSubtreeStream *stream_mapExpr =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule mapExpr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:249:5: ( ( includeExpr -> includeExpr ) (p= '.' ID -> ^( PROP[$p,@\"PROP\"] $memberExpr ID ) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr ) )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:249:9: ( includeExpr -> includeExpr ) (p= '.' ID -> ^( PROP[$p,@\"PROP\"] $memberExpr ID ) |p= '.' '(' mapExpr ')' -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr ) )* // alt
        {

        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:249:9: ( includeExpr -> includeExpr ) // blockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:249:10: includeExpr // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_includeExpr_in_memberExpr2088];
        includeExpr91 = [self includeExpr];

        [self popFollow];


        [stream_includeExpr addElement:[includeExpr91 getTree]];

        // AST REWRITE
        // elements: includeExpr
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 249:21: -> includeExpr
        {
            [treeAdaptor addChild:[stream_includeExpr nextTree] toTree:root_0];

        }


        retval.tree = root_0;


        }



        do {
            NSInteger alt33=3;
            NSInteger LA33_0 = [input LA:1];
            if ( (LA33_0==DOT) ) {
                NSInteger LA33_2 = [input LA:2];
                if ( (LA33_2==ID) ) {
                    alt33=1;
                }
                else if ( (LA33_2==LPAREN) ) {
                    alt33=2;
                }


            }


            switch (alt33) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:250:13: p= '.' ID // alt
                    {

                    p=(STToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_memberExpr2107];  
                        [stream_DOT addElement:p];


                    ID92=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_memberExpr2109];  
                        [stream_ID addElement:ID92];


                    // AST REWRITE
                    // elements: memberExpr, ID
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleSubtreeStream *stream_retval =
                        [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                    root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 250:49: -> ^( PROP[$p,@\"PROP\"] $memberExpr ID )
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:250:52: ^( PROP[$p,@\"PROP\"] $memberExpr ID )
                        {
                            CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                    [[treeAdaptor createTree:PROP FromToken:p Text:@"PROP"] retain]
                             old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                             // TODO: args: 
                            [treeAdaptor addChild:
                                        [stream_ID nextNode]
                             toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:251:13: p= '.' '(' mapExpr ')' // alt
                    {

                    p=(STToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_memberExpr2164];  
                        [stream_DOT addElement:p];


                    char_literal93=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_memberExpr2166];  
                        [stream_LPAREN addElement:char_literal93];


                    /* ruleRef */
                    [self pushFollow:FOLLOW_mapExpr_in_memberExpr2168];
                    mapExpr94 = [self mapExpr];

                    [self popFollow];


                    [stream_mapExpr addElement:[mapExpr94 getTree]];

                    char_literal95=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_memberExpr2170];  
                        [stream_RPAREN addElement:char_literal95];


                    // AST REWRITE
                    // elements: mapExpr, memberExpr
                    // token labels: 
                    // rule labels: retval
                    // token list labels: 
                    // rule list labels: 
                    // wildcard labels: 
                    retval.tree = root_0;

                    RewriteRuleSubtreeStream *stream_retval =
                        [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                            description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                    root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                    // 251:49: -> ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr )
                    {
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:251:52: ^( PROP_IND[$p,@\"PROP_IND\"] $memberExpr mapExpr )
                        {
                            CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                            root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                    [[treeAdaptor createTree:PROP_IND FromToken:p Text:@"PROP_IND"] retain]
                             old:root_1];

                            [treeAdaptor addChild:[stream_retval nextTree] toTree:root_1];

                            [treeAdaptor addChild:[stream_mapExpr nextTree] toTree:root_1];

                            [treeAdaptor addChild:root_1 toTree:root_0];
                        }

                    }


                    retval.tree = root_0;


                    }
                    break;

                default :
                    goto loop33;
            }
        } while (YES);
        loop33: ;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_RPAREN release];
        [stream_DOT release];
        [stream_ID release];
        [stream_LPAREN release];
        [stream_includeExpr release];
        [stream_mapExpr release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end memberExpr */

/*
 * $ANTLR start includeExpr
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:255:1: includeExpr options {k=2; } : ({...}? ID '(' ( expr )? ')' -> ^( EXEC_FUNC ID ( expr )? ) | 'super' '.' ID '(' args ')' -> ^( INCLUDE_SUPER ID ( args )? ) | ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | '@' 'super' '.' ID '(' rp= ')' -> ^( INCLUDE_SUPER_REGION ID ) | '@' ID '(' rp= ')' -> ^( INCLUDE_REGION ID ) | primary );
 */
- (STParser_includeExpr_return *) includeExpr
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_includeExpr_return * retval = [STParser_includeExpr_return newSTParser_includeExpr_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *rp = nil;
        STToken *ID96 = nil;
        STToken *char_literal97 = nil;
        STToken *char_literal99 = nil;
        STToken *string_literal100 = nil;
        STToken *char_literal101 = nil;
        STToken *ID102 = nil;
        STToken *char_literal103 = nil;
        STToken *char_literal105 = nil;
        STToken *ID106 = nil;
        STToken *char_literal107 = nil;
        STToken *char_literal109 = nil;
        STToken *char_literal110 = nil;
        STToken *string_literal111 = nil;
        STToken *char_literal112 = nil;
        STToken *ID113 = nil;
        STToken *char_literal114 = nil;
        STToken *char_literal115 = nil;
        STToken *ID116 = nil;
        STToken *char_literal117 = nil;
         STParser_expr_return * expr98 = nil ;
         
         STParser_args_return * args104 = nil ;
         
         STParser_args_return * args108 = nil ;
         
         STParser_primary_return * primary118 = nil ;
         

        CommonTree *rp_tree=nil;
        CommonTree *ID96_tree=nil;
        CommonTree *char_literal97_tree=nil;
        CommonTree *char_literal99_tree=nil;
        CommonTree *string_literal100_tree=nil;
        CommonTree *char_literal101_tree=nil;
        CommonTree *ID102_tree=nil;
        CommonTree *char_literal103_tree=nil;
        CommonTree *char_literal105_tree=nil;
        CommonTree *ID106_tree=nil;
        CommonTree *char_literal107_tree=nil;
        CommonTree *char_literal109_tree=nil;
        CommonTree *char_literal110_tree=nil;
        CommonTree *string_literal111_tree=nil;
        CommonTree *char_literal112_tree=nil;
        CommonTree *ID113_tree=nil;
        CommonTree *char_literal114_tree=nil;
        CommonTree *char_literal115_tree=nil;
        CommonTree *ID116_tree=nil;
        CommonTree *char_literal117_tree=nil;
        RewriteRuleTokenStream *stream_AT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token AT"] retain];
        RewriteRuleTokenStream *stream_RPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        RewriteRuleTokenStream *stream_SUPER =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token SUPER"] retain];
        RewriteRuleTokenStream *stream_DOT =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token DOT"] retain];
        RewriteRuleTokenStream *stream_ID =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        RewriteRuleTokenStream *stream_LPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        RewriteRuleSubtreeStream *stream_args =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule args"] retain];
        RewriteRuleSubtreeStream *stream_expr =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:257:5: ({...}? ID '(' ( expr )? ')' -> ^( EXEC_FUNC ID ( expr )? ) | 'super' '.' ID '(' args ')' -> ^( INCLUDE_SUPER ID ( args )? ) | ID '(' args ')' -> ^( INCLUDE ID ( args )? ) | '@' 'super' '.' ID '(' rp= ')' -> ^( INCLUDE_SUPER_REGION ID ) | '@' ID '(' rp= ')' -> ^( INCLUDE_REGION ID ) | primary ) //ruleblock
        NSInteger alt35=6;
        NSInteger LA35_0 = [input LA:1];

        if ( (LA35_0==ID) ) {
            NSInteger LA35_1 = [input LA:2];

            if ( (LA35_1==LPAREN) ) {
                NSInteger LA35_10 = [input LA:3];

                if ( (([[Compiler funcs] instrForKey:[input LT:1].text])) ) {
                    alt35=1;
                }
                else if ( (YES) ) {
                    alt35=3;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:35 state:10 stream:input];
                    nvae.c = LA35_10;
                    @throw nvae;

                }
            }
            else if ( (LA35_1==SEMI||LA35_1==COLON||LA35_1==RPAREN||(LA35_1 >= RBRACK && LA35_1 <= DOT)||LA35_1==RDELIM||(LA35_1 >= OR && LA35_1 <= AND)) ) {
                alt35=6;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:35 state:1 stream:input];
                nvae.c = LA35_1;
                @throw nvae;

            }
        }
        else if ( (LA35_0==SUPER) ) {
            alt35=2;
        }
        else if ( (LA35_0==AT) ) {
            NSInteger LA35_3 = [input LA:2];

            if ( (LA35_3==SUPER) ) {
                alt35=4;
            }
            else if ( (LA35_3==ID) ) {
                alt35=5;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:35 state:3 stream:input];
                nvae.c = LA35_3;
                @throw nvae;

            }
        }
        else if ( (LA35_0==STRING||(LA35_0 >= T_FALSE && LA35_0 <= T_TRUE)||LA35_0==LBRACK||LA35_0==LCURLY) ) {
            alt35=6;
        }
        else if ( (LA35_0==LPAREN) && ((([conditional_stack size]>0)||([conditional_stack size]==0)))) {
            alt35=6;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:35 state:0 stream:input];
            nvae.c = LA35_0;
            @throw nvae;

        }
        switch (alt35) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:257:9: {...}? ID '(' ( expr )? ')' // alt
                {

                if ( !(([[Compiler funcs] instrForKey:[input LT:1].text])) ) {
                    @throw [FailedPredicateException newException:@"includeExpr" predicate:@"[[Compiler funcs] instrForKey:[input LT:1].text]" stream:input];
                }

                ID96=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2245];  
                    [stream_ID addElement:ID96];


                char_literal97=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2247];  
                    [stream_LPAREN addElement:char_literal97];


                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:258:16: ( expr )? // block
                NSInteger alt34=2;
                NSInteger LA34_0 = [input LA:1];

                if ( (LA34_0==ID||LA34_0==STRING||(LA34_0 >= T_FALSE && LA34_0 <= T_TRUE)||LA34_0==SUPER||LA34_0==LBRACK||LA34_0==LCURLY||LA34_0==AT) ) {
                    alt34=1;
                }
                else if ( (LA34_0==LPAREN) && ((([conditional_stack size]>0)||([conditional_stack size]==0)))) {
                    alt34=1;
                }
                switch (alt34) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:258:16: expr // alt
                        {

                        /* ruleRef */
                        [self pushFollow:FOLLOW_expr_in_includeExpr2249];
                        expr98 = [self expr];

                        [self popFollow];


                        [stream_expr addElement:[expr98 getTree]];

                        }
                        break;

                }


                char_literal99=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2252];  
                    [stream_RPAREN addElement:char_literal99];


                // AST REWRITE
                // elements: ID, expr
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 258:49: -> ^( EXEC_FUNC ID ( expr )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:258:52: ^( EXEC_FUNC ID ( expr )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:EXEC_FUNC Text:@"EXEC_FUNC"] retain]
                         old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:
                                    [stream_ID nextNode]
                         toTree:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:258:67: ( expr )?
                        if ( [stream_expr hasNext] ) {
                        	[treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                        }
                        [stream_expr reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:259:9: 'super' '.' ID '(' args ')' // alt
                {

                string_literal100=(STToken *)[self match:input TokenType:SUPER Follow:FOLLOW_SUPER_in_includeExpr2296];  
                    [stream_SUPER addElement:string_literal100];


                char_literal101=(STToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_includeExpr2298];  
                    [stream_DOT addElement:char_literal101];


                ID102=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2300];  
                    [stream_ID addElement:ID102];


                char_literal103=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2302];  
                    [stream_LPAREN addElement:char_literal103];


                /* ruleRef */
                [self pushFollow:FOLLOW_args_in_includeExpr2304];
                args104 = [self args];

                [self popFollow];


                [stream_args addElement:[args104 getTree]];

                char_literal105=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2306];  
                    [stream_RPAREN addElement:char_literal105];


                // AST REWRITE
                // elements: args, ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 259:49: -> ^( INCLUDE_SUPER ID ( args )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:259:52: ^( INCLUDE_SUPER ID ( args )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:INCLUDE_SUPER Text:@"INCLUDE_SUPER"] retain]
                         old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:
                                    [stream_ID nextNode]
                         toTree:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:259:71: ( args )?
                        if ( [stream_args hasNext] ) {
                        	[treeAdaptor addChild:[stream_args nextTree] toTree:root_1];

                        }
                        [stream_args reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:260:9: ID '(' args ')' // alt
                {

                ID106=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2339];  
                    [stream_ID addElement:ID106];


                char_literal107=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2341];  
                    [stream_LPAREN addElement:char_literal107];


                /* ruleRef */
                [self pushFollow:FOLLOW_args_in_includeExpr2343];
                args108 = [self args];

                [self popFollow];


                [stream_args addElement:[args108 getTree]];

                char_literal109=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2345];  
                    [stream_RPAREN addElement:char_literal109];


                // AST REWRITE
                // elements: args, ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 260:49: -> ^( INCLUDE ID ( args )? )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:260:52: ^( INCLUDE ID ( args )? )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:INCLUDE Text:@"INCLUDE"] retain]
                         old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:
                                    [stream_ID nextNode]
                         toTree:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:260:65: ( args )?
                        if ( [stream_args hasNext] ) {
                        	[treeAdaptor addChild:[stream_args nextTree] toTree:root_1];

                        }
                        [stream_args reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:261:9: '@' 'super' '.' ID '(' rp= ')' // alt
                {

                char_literal110=(STToken *)[self match:input TokenType:AT Follow:FOLLOW_AT_in_includeExpr2390];  
                    [stream_AT addElement:char_literal110];


                string_literal111=(STToken *)[self match:input TokenType:SUPER Follow:FOLLOW_SUPER_in_includeExpr2392];  
                    [stream_SUPER addElement:string_literal111];


                char_literal112=(STToken *)[self match:input TokenType:DOT Follow:FOLLOW_DOT_in_includeExpr2394];  
                    [stream_DOT addElement:char_literal112];


                ID113=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2396];  
                    [stream_ID addElement:ID113];


                char_literal114=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2398];  
                    [stream_LPAREN addElement:char_literal114];


                rp=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2402];  
                    [stream_RPAREN addElement:rp];


                // AST REWRITE
                // elements: ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 261:49: -> ^( INCLUDE_SUPER_REGION ID )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:261:52: ^( INCLUDE_SUPER_REGION ID )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:INCLUDE_SUPER_REGION Text:@"INCLUDE_SUPER_REGION"] retain]
                         old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:
                                    [stream_ID nextNode]
                         toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 5 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:262:9: '@' ID '(' rp= ')' // alt
                {

                char_literal115=(STToken *)[self match:input TokenType:AT Follow:FOLLOW_AT_in_includeExpr2430];  
                    [stream_AT addElement:char_literal115];


                ID116=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_includeExpr2432];  
                    [stream_ID addElement:ID116];


                char_literal117=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_includeExpr2434];  
                    [stream_LPAREN addElement:char_literal117];


                rp=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_includeExpr2438];  
                    [stream_RPAREN addElement:rp];


                // AST REWRITE
                // elements: ID
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 262:49: -> ^( INCLUDE_REGION ID )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:262:52: ^( INCLUDE_REGION ID )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:INCLUDE_REGION Text:@"INCLUDE_REGION"] retain]
                         old:root_1];

                         // TODO: args: 
                        [treeAdaptor addChild:
                                    [stream_ID nextNode]
                         toTree:root_1];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;
            case 6 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:263:9: primary // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_primary_in_includeExpr2478];
                primary118 = [self primary];

                [self popFollow];


                [treeAdaptor addChild:[primary118 getTree] toTree:root_0];

                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_AT release];
        [stream_RPAREN release];
        [stream_SUPER release];
        [stream_DOT release];
        [stream_ID release];
        [stream_LPAREN release];
        [stream_args release];
        [stream_expr release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end includeExpr */

/*
 * $ANTLR start primary
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:266:1: primary : ( ID | STRING | T_TRUE | T_FALSE | subtemplate | list |{...}? => '(' ! conditional ')' !|{...}? =>lp= '(' expr ')' ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) );
 */
- (STParser_primary_return *) primary
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_primary_return * retval = [STParser_primary_return newSTParser_primary_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *lp = nil;
        STToken *ID119 = nil;
        STToken *STRING120 = nil;
        STToken *T_TRUE121 = nil;
        STToken *T_FALSE122 = nil;
        STToken *char_literal125 = nil;
        STToken *char_literal127 = nil;
        STToken *char_literal129 = nil;
        STToken *char_literal130 = nil;
        STToken *char_literal132 = nil;
         STParser_subtemplate_return * subtemplate123 = nil ;
         
         STParser_list_return * list124 = nil ;
         
         STParser_conditional_return * conditional126 = nil ;
         
         STParser_expr_return * expr128 = nil ;
         
         STParser_argExprList_return * argExprList131 = nil ;
         

        CommonTree *lp_tree=nil;
        CommonTree *ID119_tree=nil;
        CommonTree *STRING120_tree=nil;
        CommonTree *T_TRUE121_tree=nil;
        CommonTree *T_FALSE122_tree=nil;
        CommonTree *char_literal125_tree=nil;
        CommonTree *char_literal127_tree=nil;
        CommonTree *char_literal129_tree=nil;
        CommonTree *char_literal130_tree=nil;
        CommonTree *char_literal132_tree=nil;
        RewriteRuleTokenStream *stream_RPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RPAREN"] retain];
        RewriteRuleTokenStream *stream_LPAREN =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LPAREN"] retain];
        RewriteRuleSubtreeStream *stream_argExprList =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule argExprList"] retain];
        RewriteRuleSubtreeStream *stream_expr =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule expr"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:267:5: ( ID | STRING | T_TRUE | T_FALSE | subtemplate | list |{...}? => '(' ! conditional ')' !|{...}? =>lp= '(' expr ')' ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) ) //ruleblock
        NSInteger alt38=8;
        NSInteger LA38_0 = [input LA:1];

        if ( (LA38_0==ID) ) {
            alt38=1;
        }
        else if ( (LA38_0==STRING) ) {
            alt38=2;
        }
        else if ( (LA38_0==T_TRUE) ) {
            alt38=3;
        }
        else if ( (LA38_0==T_FALSE) ) {
            alt38=4;
        }
        else if ( (LA38_0==LCURLY) ) {
            alt38=5;
        }
        else if ( (LA38_0==LBRACK) ) {
            alt38=6;
        }
        else if ( (LA38_0==LPAREN) && ((([conditional_stack size]>0)||([conditional_stack size]==0)))) {
            NSInteger LA38_7 = [input LA:2];

            if ( (([conditional_stack size]>0)) ) {
                alt38=7;
            }
            else if ( (([conditional_stack size]==0)) ) {
                alt38=8;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:38 state:7 stream:input];
                nvae.c = LA38_7;
                @throw nvae;

            }
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:38 state:0 stream:input];
            nvae.c = LA38_0;
            @throw nvae;

        }
        switch (alt38) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:267:9: ID // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser tokenRef */
                ID119=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_primary2497]; 
                ID119_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[[treeAdaptor create:ID119] retain]
                ;
                [treeAdaptor addChild:ID119_tree  toTree:root_0];


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:268:9: STRING // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser tokenRef */
                STRING120=(STToken *)[self match:input TokenType:STRING Follow:FOLLOW_STRING_in_primary2507]; 
                STRING120_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[[treeAdaptor create:STRING120] retain]
                ;
                [treeAdaptor addChild:STRING120_tree  toTree:root_0];


                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:269:9: T_TRUE // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser tokenRef */
                T_TRUE121=(STToken *)[self match:input TokenType:T_TRUE Follow:FOLLOW_T_TRUE_in_primary2517]; 
                T_TRUE121_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[[treeAdaptor create:T_TRUE121] retain]
                ;
                [treeAdaptor addChild:T_TRUE121_tree  toTree:root_0];


                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:270:9: T_FALSE // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser tokenRef */
                T_FALSE122=(STToken *)[self match:input TokenType:T_FALSE Follow:FOLLOW_T_FALSE_in_primary2527]; 
                T_FALSE122_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[[treeAdaptor create:T_FALSE122] retain]
                ;
                [treeAdaptor addChild:T_FALSE122_tree  toTree:root_0];


                }
                break;
            case 5 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:271:9: subtemplate // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_subtemplate_in_primary2537];
                subtemplate123 = [self subtemplate];

                [self popFollow];


                [treeAdaptor addChild:[subtemplate123 getTree] toTree:root_0];

                }
                break;
            case 6 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:272:9: list // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_list_in_primary2547];
                list124 = [self list];

                [self popFollow];


                [treeAdaptor addChild:[list124 getTree] toTree:root_0];

                }
                break;
            case 7 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:273:9: {...}? => '(' ! conditional ')' ! // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                if ( !(([conditional_stack size]>0)) ) {
                    @throw [FailedPredicateException newException:@"primary" predicate:@"[$conditional size]>0" stream:input];
                }

                char_literal125=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_primary2561]; 

                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_conditional_in_primary2564];
                conditional126 = [self conditional];

                [self popFollow];


                [treeAdaptor addChild:[conditional126 getTree] toTree:root_0];

                char_literal127=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_primary2566]; 

                }
                break;
            case 8 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:274:9: {...}? =>lp= '(' expr ')' ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) // alt
                {

                if ( !(([conditional_stack size]==0)) ) {
                    @throw [FailedPredicateException newException:@"primary" predicate:@"[$conditional size]==0" stream:input];
                }

                lp=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_primary2582];  
                    [stream_LPAREN addElement:lp];


                /* ruleRef */
                [self pushFollow:FOLLOW_expr_in_primary2584];
                expr128 = [self expr];

                [self popFollow];


                [stream_expr addElement:[expr128 getTree]];

                char_literal129=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_primary2586];  
                    [stream_RPAREN addElement:char_literal129];


                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:275:9: ( '(' ( argExprList )? ')' -> ^( INCLUDE_IND[$lp] expr ( argExprList )? ) | -> ^( TO_STR[$lp] expr ) ) // block
                NSInteger alt37=2;
                NSInteger LA37_0 = [input LA:1];

                if ( (LA37_0==LPAREN) ) {
                    alt37=1;
                }
                else if ( (LA37_0==SEMI||LA37_0==COLON||LA37_0==RPAREN||(LA37_0 >= RBRACK && LA37_0 <= DOT)||LA37_0==RDELIM||(LA37_0 >= OR && LA37_0 <= AND)) ) {
                    alt37=2;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:37 state:0 stream:input];
                    nvae.c = LA37_0;
                    @throw nvae;

                }
                switch (alt37) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:275:13: '(' ( argExprList )? ')' // alt
                        {

                        char_literal130=(STToken *)[self match:input TokenType:LPAREN Follow:FOLLOW_LPAREN_in_primary2600];  
                            [stream_LPAREN addElement:char_literal130];


                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:275:17: ( argExprList )? // block
                        NSInteger alt36=2;
                        NSInteger LA36_0 = [input LA:1];

                        if ( (LA36_0==ID||LA36_0==STRING||(LA36_0 >= T_FALSE && LA36_0 <= T_TRUE)||LA36_0==SUPER||LA36_0==LBRACK||LA36_0==LCURLY||LA36_0==AT) ) {
                            alt36=1;
                        }
                        else if ( (LA36_0==LPAREN) && ((([conditional_stack size]>0)||([conditional_stack size]==0)))) {
                            alt36=1;
                        }
                        switch (alt36) {
                            case 1 : ;
                                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:275:17: argExprList // alt
                                {

                                /* ruleRef */
                                [self pushFollow:FOLLOW_argExprList_in_primary2602];
                                argExprList131 = [self argExprList];

                                [self popFollow];


                                [stream_argExprList addElement:[argExprList131 getTree]];

                                }
                                break;

                        }


                        char_literal132=(STToken *)[self match:input TokenType:RPAREN Follow:FOLLOW_RPAREN_in_primary2605];  
                            [stream_RPAREN addElement:char_literal132];


                        // AST REWRITE
                        // elements: argExprList, expr
                        // token labels: 
                        // rule labels: retval
                        // token list labels: 
                        // rule list labels: 
                        // wildcard labels: 
                        retval.tree = root_0;

                        RewriteRuleSubtreeStream *stream_retval =
                            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                        // 275:49: -> ^( INCLUDE_IND[$lp] expr ( argExprList )? )
                        {
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:275:52: ^( INCLUDE_IND[$lp] expr ( argExprList )? )
                            {
                                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                        [[treeAdaptor createTree:INCLUDE_IND FromToken:lp Text:@"INCLUDE_IND"] retain]
                                 old:root_1];

                                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:275:76: ( argExprList )?
                                if ( [stream_argExprList hasNext] ) {
                                	[treeAdaptor addChild:[stream_argExprList nextTree] toTree:root_1];

                                }
                                [stream_argExprList reset];

                                [treeAdaptor addChild:root_1 toTree:root_0];
                            }

                        }


                        retval.tree = root_0;


                        }
                        break;
                    case 2 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:276:49:  // alt
                        {
                        // AST REWRITE
                        // elements: expr
                        // token labels: 
                        // rule labels: retval
                        // token list labels: 
                        // rule list labels: 
                        // wildcard labels: 
                        retval.tree = root_0;

                        RewriteRuleSubtreeStream *stream_retval =
                            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                        // 276:49: -> ^( TO_STR[$lp] expr )
                        {
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:276:52: ^( TO_STR[$lp] expr )
                            {
                                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                        [[treeAdaptor createTree:TO_STR FromToken:lp Text:@"TO_STR"] retain]
                                 old:root_1];

                                [treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

                                [treeAdaptor addChild:root_1 toTree:root_0];
                            }

                        }


                        retval.tree = root_0;


                        }
                        break;

                }


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_RPAREN release];
        [stream_LPAREN release];
        [stream_argExprList release];
        [stream_expr release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end primary */

/*
 * $ANTLR start args
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:280:1: args : ( argExprList | namedArg ( ',' namedArg )* ( ',' '...' )? -> ( namedArg )+ ( '...' )? | '...' |);
 */
- (STParser_args_return *) args
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_args_return * retval = [STParser_args_return newSTParser_args_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *char_literal135 = nil;
        STToken *char_literal137 = nil;
        STToken *string_literal138 = nil;
        STToken *string_literal139 = nil;
         STParser_argExprList_return * argExprList133 = nil ;
         
         STParser_namedArg_return * namedArg134 = nil ;
         
         STParser_namedArg_return * namedArg136 = nil ;
         

        CommonTree *char_literal135_tree=nil;
        CommonTree *char_literal137_tree=nil;
        CommonTree *string_literal138_tree=nil;
        CommonTree *string_literal139_tree=nil;
        RewriteRuleTokenStream *stream_ELLIPSIS =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ELLIPSIS"] retain];
        RewriteRuleTokenStream *stream_COMMA =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        RewriteRuleSubtreeStream *stream_namedArg =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule namedArg"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:280:5: ( argExprList | namedArg ( ',' namedArg )* ( ',' '...' )? -> ( namedArg )+ ( '...' )? | '...' |) //ruleblock
        NSInteger alt41=4;
        NSInteger LA41_0 = [input LA:1];

        if ( (LA41_0==ID) ) {
            NSInteger LA41_1 = [input LA:2];

            if ( ((LA41_1 >= COLON && LA41_1 <= RPAREN)||(LA41_1 >= COMMA && LA41_1 <= DOT)) ) {
                alt41=1;
            }
            else if ( (LA41_1==EQUALS) ) {
                alt41=2;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:41 state:1 stream:input];
                nvae.c = LA41_1;
                @throw nvae;

            }
        }
        else if ( (LA41_0==STRING||(LA41_0 >= T_FALSE && LA41_0 <= T_TRUE)||LA41_0==SUPER||LA41_0==LBRACK||LA41_0==LCURLY||LA41_0==AT) ) {
            alt41=1;
        }
        else if ( (LA41_0==LPAREN) && ((([conditional_stack size]>0)||([conditional_stack size]==0)))) {
            alt41=1;
        }
        else if ( (LA41_0==ELLIPSIS) ) {
            alt41=3;
        }
        else if ( (LA41_0==RPAREN) ) {
            alt41=4;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:41 state:0 stream:input];
            nvae.c = LA41_0;
            @throw nvae;

        }
        switch (alt41) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:280:9: argExprList // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_argExprList_in_args2713];
                argExprList133 = [self argExprList];

                [self popFollow];


                [treeAdaptor addChild:[argExprList133 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:281:9: namedArg ( ',' namedArg )* ( ',' '...' )? // alt
                {

                /* ruleRef */
                [self pushFollow:FOLLOW_namedArg_in_args2723];
                namedArg134 = [self namedArg];

                [self popFollow];


                [stream_namedArg addElement:[namedArg134 getTree]];


                do {
                    NSInteger alt39=2;
                    NSInteger LA39_0 = [input LA:1];
                    if ( (LA39_0==COMMA) ) {
                        NSInteger LA39_1 = [input LA:2];
                        if ( (LA39_1==ID) ) {
                            alt39=1;
                        }


                    }


                    switch (alt39) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:281:20: ',' namedArg // alt
                            {

                            char_literal135=(STToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_args2727];  
                                [stream_COMMA addElement:char_literal135];


                            /* ruleRef */
                            [self pushFollow:FOLLOW_namedArg_in_args2729];
                            namedArg136 = [self namedArg];

                            [self popFollow];


                            [stream_namedArg addElement:[namedArg136 getTree]];

                            }
                            break;

                        default :
                            goto loop39;
                    }
                } while (YES);
                loop39: ;


                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:281:36: ( ',' '...' )? // block
                NSInteger alt40=2;
                NSInteger LA40_0 = [input LA:1];

                if ( (LA40_0==COMMA) ) {
                    alt40=1;
                }
                switch (alt40) {
                    case 1 : ;
                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:281:37: ',' '...' // alt
                        {

                        char_literal137=(STToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_args2735];  
                            [stream_COMMA addElement:char_literal137];


                        string_literal138=(STToken *)[self match:input TokenType:ELLIPSIS Follow:FOLLOW_ELLIPSIS_in_args2737];  
                            [stream_ELLIPSIS addElement:string_literal138];


                        }
                        break;

                }


                // AST REWRITE
                // elements: ELLIPSIS, namedArg
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 281:49: -> ( namedArg )+ ( '...' )?
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:281:52: ( namedArg )+
                    {
                    if ( !([stream_namedArg hasNext]) ) {
                        @throw [RewriteEarlyExitException newException];
                    }
                    while ( [stream_namedArg hasNext] ) {
                        [treeAdaptor addChild:[stream_namedArg nextTree] toTree:root_0];

                    }
                    [stream_namedArg reset];

                    }
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:281:62: ( '...' )?
                    if ( [stream_ELLIPSIS hasNext] ) {
                    	 // TODO: args: 
                    	[treeAdaptor addChild:
                    	            [stream_ELLIPSIS nextNode]
                    	 toTree:root_0];

                    }
                    [stream_ELLIPSIS reset];

                }


                retval.tree = root_0;


                }
                break;
            case 3 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:282:9: '...' // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser tokenRef */
                string_literal139=(STToken *)[self match:input TokenType:ELLIPSIS Follow:FOLLOW_ELLIPSIS_in_args2757]; 
                string_literal139_tree = /* ASTParser createNodeFromToken */
                (CommonTree *)[[treeAdaptor create:string_literal139] retain]
                ;
                [treeAdaptor addChild:string_literal139_tree  toTree:root_0];


                }
                break;
            case 4 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:284:5:  // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_ELLIPSIS release];
        [stream_COMMA release];
        [stream_namedArg release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end args */

/*
 * $ANTLR start argExprList
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:286:1: argExprList : arg ( ',' arg )* -> ( arg )+ ;
 */
- (STParser_argExprList_return *) argExprList
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_argExprList_return * retval = [STParser_argExprList_return newSTParser_argExprList_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *char_literal141 = nil;
         STParser_arg_return * arg140 = nil ;
         
         STParser_arg_return * arg142 = nil ;
         

        CommonTree *char_literal141_tree=nil;
        RewriteRuleTokenStream *stream_COMMA =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        RewriteRuleSubtreeStream *stream_arg =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule arg"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:286:13: ( arg ( ',' arg )* -> ( arg )+ ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:286:15: arg ( ',' arg )* // alt
        {

        /* ruleRef */
        [self pushFollow:FOLLOW_arg_in_argExprList2776];
        arg140 = [self arg];

        [self popFollow];


        [stream_arg addElement:[arg140 getTree]];


        do {
            NSInteger alt42=2;
            NSInteger LA42_0 = [input LA:1];
            if ( (LA42_0==COMMA) ) {
                alt42=1;
            }


            switch (alt42) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:286:21: ',' arg // alt
                    {

                    char_literal141=(STToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_argExprList2780];  
                        [stream_COMMA addElement:char_literal141];


                    /* ruleRef */
                    [self pushFollow:FOLLOW_arg_in_argExprList2782];
                    arg142 = [self arg];

                    [self popFollow];


                    [stream_arg addElement:[arg142 getTree]];

                    }
                    break;

                default :
                    goto loop42;
            }
        } while (YES);
        loop42: ;


        // AST REWRITE
        // elements: arg
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 286:32: -> ( arg )+
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:286:35: ( arg )+
            {
            if ( !([stream_arg hasNext]) ) {
                @throw [RewriteEarlyExitException newException];
            }
            while ( [stream_arg hasNext] ) {
                [treeAdaptor addChild:[stream_arg nextTree] toTree:root_0];

            }
            [stream_arg reset];

            }
        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_COMMA release];
        [stream_arg release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end argExprList */

/*
 * $ANTLR start arg
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:288:1: arg : exprNoComma ;
 */
- (STParser_arg_return *) arg
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_arg_return * retval = [STParser_arg_return newSTParser_arg_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
         STParser_exprNoComma_return * exprNoComma143 = nil ;
         


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:288:5: ( exprNoComma ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:288:7: exprNoComma // alt
        {
        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



        /* ASTParser ruleRef */
        /* ruleRef */
        [self pushFollow:FOLLOW_exprNoComma_in_arg2799];
        exprNoComma143 = [self exprNoComma];

        [self popFollow];


        [treeAdaptor addChild:[exprNoComma143 getTree] toTree:root_0];

        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end arg */

/*
 * $ANTLR start namedArg
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:290:1: namedArg : ID '=' arg -> ^( '=' ID arg ) ;
 */
- (STParser_namedArg_return *) namedArg
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_namedArg_return * retval = [STParser_namedArg_return newSTParser_namedArg_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *ID144 = nil;
        STToken *char_literal145 = nil;
         STParser_arg_return * arg146 = nil ;
         

        CommonTree *ID144_tree=nil;
        CommonTree *char_literal145_tree=nil;
        RewriteRuleTokenStream *stream_EQUALS =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token EQUALS"] retain];
        RewriteRuleTokenStream *stream_ID =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token ID"] retain];
        RewriteRuleSubtreeStream *stream_arg =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule arg"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:290:10: ( ID '=' arg -> ^( '=' ID arg ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:290:12: ID '=' arg // alt
        {

        ID144=(STToken *)[self match:input TokenType:ID Follow:FOLLOW_ID_in_namedArg2808];  
            [stream_ID addElement:ID144];


        char_literal145=(STToken *)[self match:input TokenType:EQUALS Follow:FOLLOW_EQUALS_in_namedArg2810];  
            [stream_EQUALS addElement:char_literal145];


        /* ruleRef */
        [self pushFollow:FOLLOW_arg_in_namedArg2812];
        arg146 = [self arg];

        [self popFollow];


        [stream_arg addElement:[arg146 getTree]];

        // AST REWRITE
        // elements: ID, EQUALS, arg
        // token labels: 
        // rule labels: retval
        // token list labels: 
        // rule list labels: 
        // wildcard labels: 
        retval.tree = root_0;

        RewriteRuleSubtreeStream *stream_retval =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

        root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

        // 290:23: -> ^( '=' ID arg )
        {
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:290:26: ^( '=' ID arg )
            {
                CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                            [stream_EQUALS nextNode]
                 old:root_1];

                 // TODO: args: 
                [treeAdaptor addChild:
                            [stream_ID nextNode]
                 toTree:root_1];

                [treeAdaptor addChild:[stream_arg nextTree] toTree:root_1];

                [treeAdaptor addChild:root_1 toTree:root_0];
            }

        }


        retval.tree = root_0;


        }

        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_EQUALS release];
        [stream_ID release];
        [stream_arg release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end namedArg */

/*
 * $ANTLR start list
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:292:1: list : ({...}?lb= '[' ']' -> LIST[$lb] |lb= '[' listElement ( ',' listElement )* ']' -> ^( LIST[$lb] ( listElement )* ) );
 */
- (STParser_list_return *) list
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_list_return * retval = [STParser_list_return newSTParser_list_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
        STToken *lb = nil;
        STToken *char_literal147 = nil;
        STToken *char_literal149 = nil;
        STToken *char_literal151 = nil;
         STParser_listElement_return * listElement148 = nil ;
         
         STParser_listElement_return * listElement150 = nil ;
         

        CommonTree *lb_tree=nil;
        CommonTree *char_literal147_tree=nil;
        CommonTree *char_literal149_tree=nil;
        CommonTree *char_literal151_tree=nil;
        RewriteRuleTokenStream *stream_RBRACK =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token RBRACK"] retain];
        RewriteRuleTokenStream *stream_LBRACK =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token LBRACK"] retain];
        RewriteRuleTokenStream *stream_COMMA =
            [[RewriteRuleTokenStream newRewriteRuleTokenStream:treeAdaptor
                                                             description:@"token COMMA"] retain];
        RewriteRuleSubtreeStream *stream_listElement =
            [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                                                                description:@"rule listElement"] retain];
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:292:5: ({...}?lb= '[' ']' -> LIST[$lb] |lb= '[' listElement ( ',' listElement )* ']' -> ^( LIST[$lb] ( listElement )* ) ) //ruleblock
        NSInteger alt44=2;
        NSInteger LA44_0 = [input LA:1];

        if ( (LA44_0==LBRACK) ) {
            NSInteger LA44_1 = [input LA:2];

            if ( (LA44_1==RBRACK) ) {
                NSInteger LA44_2 = [input LA:3];

                if ( (([input LA:2] == RBRACK)) ) {
                    alt44=1;
                }
                else if ( (YES) ) {
                    alt44=2;
                }
                else {
                    NoViableAltException *nvae = [NoViableAltException newException:44 state:2 stream:input];
                    nvae.c = LA44_2;
                    @throw nvae;

                }
            }
            else if ( (LA44_1==ID||LA44_1==STRING||(LA44_1 >= T_FALSE && LA44_1 <= T_TRUE)||LA44_1==SUPER||LA44_1==LPAREN||LA44_1==LBRACK||LA44_1==COMMA||LA44_1==LCURLY||LA44_1==AT) ) {
                alt44=2;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:44 state:1 stream:input];
                nvae.c = LA44_1;
                @throw nvae;

            }
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:44 state:0 stream:input];
            nvae.c = LA44_0;
            @throw nvae;

        }
        switch (alt44) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:292:9: {...}?lb= '[' ']' // alt
                {

                if ( !(([input LA:2] == RBRACK)) ) {
                    @throw [FailedPredicateException newException:@"list" predicate:@"[input LA:2] == RBRACK" stream:input];
                }

                lb=(STToken *)[self match:input TokenType:LBRACK Follow:FOLLOW_LBRACK_in_list2845];  
                    [stream_LBRACK addElement:lb];


                char_literal147=(STToken *)[self match:input TokenType:RBRACK Follow:FOLLOW_RBRACK_in_list2847];  
                    [stream_RBRACK addElement:char_literal147];


                // AST REWRITE
                // elements: 
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 293:20: -> LIST[$lb]
                {
                    [treeAdaptor addChild:
                            [[treeAdaptor createTree:LIST FromToken:lb Text:@"LIST"] retain]
                     toTree:root_0];

                }


                retval.tree = root_0;


                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:294:9: lb= '[' listElement ( ',' listElement )* ']' // alt
                {

                lb=(STToken *)[self match:input TokenType:LBRACK Follow:FOLLOW_LBRACK_in_list2864];  
                    [stream_LBRACK addElement:lb];


                /* ruleRef */
                [self pushFollow:FOLLOW_listElement_in_list2866];
                listElement148 = [self listElement];

                [self popFollow];


                [stream_listElement addElement:[listElement148 getTree]];


                do {
                    NSInteger alt43=2;
                    NSInteger LA43_0 = [input LA:1];
                    if ( (LA43_0==COMMA) ) {
                        alt43=1;
                    }


                    switch (alt43) {
                        case 1 : ;
                            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:294:30: ',' listElement // alt
                            {

                            char_literal149=(STToken *)[self match:input TokenType:COMMA Follow:FOLLOW_COMMA_in_list2870];  
                                [stream_COMMA addElement:char_literal149];


                            /* ruleRef */
                            [self pushFollow:FOLLOW_listElement_in_list2872];
                            listElement150 = [self listElement];

                            [self popFollow];


                            [stream_listElement addElement:[listElement150 getTree]];

                            }
                            break;

                        default :
                            goto loop43;
                    }
                } while (YES);
                loop43: ;


                char_literal151=(STToken *)[self match:input TokenType:RBRACK Follow:FOLLOW_RBRACK_in_list2877];  
                    [stream_RBRACK addElement:char_literal151];


                // AST REWRITE
                // elements: listElement
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 294:53: -> ^( LIST[$lb] ( listElement )* )
                {
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:294:56: ^( LIST[$lb] ( listElement )* )
                    {
                        CommonTree *root_1 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
                        root_1 = (CommonTree *)[treeAdaptor becomeRoot:
                                [[treeAdaptor createTree:LIST FromToken:lb Text:@"LIST"] retain]
                         old:root_1];

                        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:294:68: ( listElement )*
                        while ( [stream_listElement hasNext] ) {
                            [treeAdaptor addChild:[stream_listElement nextTree] toTree:root_1];

                        }
                        [stream_listElement reset];

                        [treeAdaptor addChild:root_1 toTree:root_0];
                    }

                }


                retval.tree = root_0;


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];


        [stream_RBRACK release];
        [stream_LBRACK release];
        [stream_COMMA release];
        [stream_listElement release];

            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end list */

/*
 * $ANTLR start listElement
 * /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:297:1: listElement : ( exprNoComma | -> TNULL );
 */
- (STParser_listElement_return *) listElement
{
    /* ruleScopeSetUp */

    /* AST ruleDeclarations */
    /* ruleDeclarations */
    STParser_listElement_return * retval = [STParser_listElement_return newSTParser_listElement_return];
    [retval setStart:[input LT:1]];


    CommonTree *root_0 = nil;

    @try {
        /* AST ruleLabelDefs */
         STParser_exprNoComma_return * exprNoComma152 = nil ;
         


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:297:13: ( exprNoComma | -> TNULL ) //ruleblock
        NSInteger alt45=2;
        NSInteger LA45_0 = [input LA:1];

        if ( (LA45_0==ID||LA45_0==STRING||(LA45_0 >= T_FALSE && LA45_0 <= T_TRUE)||LA45_0==SUPER||LA45_0==LBRACK||LA45_0==LCURLY||LA45_0==AT) ) {
            alt45=1;
        }
        else if ( (LA45_0==LPAREN) && ((([conditional_stack size]>0)||([conditional_stack size]==0)))) {
            alt45=1;
        }
        else if ( ((LA45_0 >= RBRACK && LA45_0 <= COMMA)) ) {
            alt45=2;
        }
        else {
            NoViableAltException *nvae = [NoViableAltException newException:45 state:0 stream:input];
            nvae.c = LA45_0;
            @throw nvae;

        }
        switch (alt45) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:297:15: exprNoComma // alt
                {
                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];



                /* ASTParser ruleRef */
                /* ruleRef */
                [self pushFollow:FOLLOW_exprNoComma_in_listElement2900];
                exprNoComma152 = [self exprNoComma];

                [self popFollow];


                [treeAdaptor addChild:[exprNoComma152 getTree] toTree:root_0];

                }
                break;
            case 2 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/STParser.g:297:29:  // alt
                {
                // AST REWRITE
                // elements: 
                // token labels: 
                // rule labels: retval
                // token list labels: 
                // rule list labels: 
                // wildcard labels: 
                retval.tree = root_0;

                RewriteRuleSubtreeStream *stream_retval =
                    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

                root_0 = (CommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

                // 297:29: -> TNULL
                {
                    [treeAdaptor addChild:
                            [[treeAdaptor createTree:TNULL Text:@"TNULL"] retain]
                     toTree:root_0];

                }


                retval.tree = root_0;


                }
                break;

        }
        /* ASTParser ruleCleanUp */
        /* AST ruleCleanUp */
        /* token+rule list labels */
        [retval setStop:[input LT:-1]];



            retval.tree = (CommonTree *)[treeAdaptor rulePostProcessing:root_0];
            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

    }

        @catch (RecognitionException *re) {
            @throw re;
        }

    @finally {
        /* ruleScopeCleanUp */

    }
    return retval;
}
/* $ANTLR end listElement */
/* ObjC end rules */

@end /* end of STParser implementation line 692 */
