/** \file
 *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
 *
 *     -  From the grammar source file : /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g
 *     -                            On : 2011-05-08 16:46:26
 *     -                 for the lexer : GroupLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2010 Alan Condit
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
// $ANTLR ${project.version} ${buildNumber} /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g 2011-05-08 16:46:26


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "GroupLexer.h"
/* ----------------------------------------- */


/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */

/** As per Terence: No returns for lexer rules! */
@implementation GroupLexer // line 330

+ (void) initialize
{
    [BaseRecognizer setGrammarFileName:@"/Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g"];
}

+ (NSString *) tokenNameForType:(NSInteger)aTokenType
{
    return [[self getTokenNames] objectAtIndex:aTokenType];
}

+ (GroupLexer *)newGroupLexerWithCharStream:(id<CharStream>)anInput
{
    return [[GroupLexer alloc] initWithCharStream:anInput];
}

- (id) initWithCharStream:(id<CharStream>)anInput
{
    self = [super initWithCharStream:anInput State:[RecognizerSharedState newRecognizerSharedStateWithRuleLen:24+1]];
    if ( self != nil ) {
    }
    return self;
}

- (void) dealloc
{
    [super dealloc];
}

/* ObjC Start of actions.lexer.methods */

@synthesize group;

- (void) reportError:(RecognitionException *)e
{
    NSString *msg = nil;
    if ( [e isKindOfClass:[NoViableAltException class]] ) {
#pragma error fix formatting
        msg = [NSString stringWithFormat:@"invalid character '%c'", [input LA:1]];
    }
    else if ( [e isKindOfClass:[MismatchedTokenException class]] && ((MismatchedTokenException *)e).expecting=='"' ) {
        msg = @"unterminated string";
    }
    else {
        msg = [self getErrorMessage:e TokenNames:[self getTokenNames]];
    }
    [group.errMgr groupSyntaxError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
}

- (NSString *) getSourceName
{
    return [super getSourceName];
}


/* ObjC end of actions.lexer.methods */
/* ObjC start methods() */
/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "T__14"
- (void) mT__14
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__14;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:79:7: ( '(' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:79:9: '(' // alt
        {
        [self matchChar:'(']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__14" */

// $ANTLR start "T__15"
- (void) mT__15
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__15;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:80:7: ( ')' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:80:9: ')' // alt
        {
        [self matchChar:')']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__15" */

// $ANTLR start "T__16"
- (void) mT__16
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__16;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:81:7: ( ',' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:81:9: ',' // alt
        {
        [self matchChar:',']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__16" */

// $ANTLR start "T__17"
- (void) mT__17
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__17;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:82:7: ( '.' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:82:9: '.' // alt
        {
        [self matchChar:'.']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__17" */

// $ANTLR start "T__18"
- (void) mT__18
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__18;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:83:7: ( ':' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:83:9: ':' // alt
        {
        [self matchChar:':']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__18" */

// $ANTLR start "T__19"
- (void) mT__19
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__19;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:84:7: ( '::=' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:84:9: '::=' // alt
        {
        [self matchString:@"::="]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__19" */

// $ANTLR start "T__20"
- (void) mT__20
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__20;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:85:7: ( ';' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:85:9: ';' // alt
        {
        [self matchChar:';']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__20" */

// $ANTLR start "T__21"
- (void) mT__21
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__21;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:86:7: ( '=' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:86:9: '=' // alt
        {
        [self matchChar:'=']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__21" */

// $ANTLR start "T__22"
- (void) mT__22
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__22;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:87:7: ( '@' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:87:9: '@' // alt
        {
        [self matchChar:'@']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__22" */

// $ANTLR start "T__23"
- (void) mT__23
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__23;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:88:7: ( '[' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:88:9: '[' // alt
        {
        [self matchChar:'[']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__23" */

// $ANTLR start "T__24"
- (void) mT__24
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__24;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:89:7: ( ']' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:89:9: ']' // alt
        {
        [self matchChar:']']; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__24" */

// $ANTLR start "T__25"
- (void) mT__25
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__25;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:90:7: ( 'default' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:90:9: 'default' // alt
        {
        [self matchString:@"default"]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__25" */

// $ANTLR start "T__26"
- (void) mT__26
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__26;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:91:7: ( 'group' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:91:9: 'group' // alt
        {
        [self matchString:@"group"]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__26" */

// $ANTLR start "T__27"
- (void) mT__27
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__27;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:92:7: ( 'implements' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:92:9: 'implements' // alt
        {
        [self matchString:@"implements"]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__27" */

// $ANTLR start "T__28"
- (void) mT__28
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = T__28;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:93:7: ( 'import' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:93:9: 'import' // alt
        {
        [self matchString:@"import"]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "T__28" */

// $ANTLR start "ID"
- (void) mID
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = ID;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:365:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:365:9: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* // alt
        {
        if ((([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
            [input consume];
        } else {
            MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
            [self recover:mse];
            @throw mse;
        }


        do {
            NSInteger alt1=2;
            NSInteger LA1_0 = [input LA:1];
            if ( (LA1_0=='-'||(LA1_0 >= '0' && LA1_0 <= '9')||(LA1_0 >= 'A' && LA1_0 <= 'Z')||LA1_0=='_'||(LA1_0 >= 'a' && LA1_0 <= 'z')) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g: // alt
                    {
                    if ([input LA:1] == '-'||(([input LA:1] >= '0') && ([input LA:1] <= '9'))||(([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }


                    }
                    break;

                default :
                    goto loop1;
            }
        } while (YES);
        loop1: ;


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "ID" */

// $ANTLR start "STRING"
- (void) mSTRING
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = STRING;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:369:5: ( '\"' ( '\\\\' '\"' | '\\\\' ~ '\"' | '\\n' |~ ( '\\\\' | '\"' | '\\n' ) )* '\"' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:369:9: '\"' ( '\\\\' '\"' | '\\\\' ~ '\"' | '\\n' |~ ( '\\\\' | '\"' | '\\n' ) )* '\"' // alt
        {
        [self matchChar:'"']; 


        do {
            NSInteger alt2=5;
            NSInteger LA2_0 = [input LA:1];
            if ( (LA2_0=='\\') ) {
                NSInteger LA2_2 = [input LA:2];
                if ( (LA2_2=='"') ) {
                    alt2=1;
                }
                else if ( ((LA2_2 >= 0x0000 && LA2_2 <= '!')||(LA2_2 >= '#' && LA2_2 <= 0xFFFF)) ) {
                    alt2=2;
                }


            }
            else if ( (LA2_0=='\n') ) {
                alt2=3;
            }
            else if ( ((LA2_0 >= 0x0000 && LA2_0 <= '\t')||(LA2_0 >= 0x000B && LA2_0 <= '!')||(LA2_0 >= '#' && LA2_0 <= '[')||(LA2_0 >= ']' && LA2_0 <= 0xFFFF)) ) {
                alt2=4;
            }


            switch (alt2) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:370:13: '\\\\' '\"' // alt
                    {
                    [self matchChar:'\\']; 


                    [self matchChar:'"']; 


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:371:13: '\\\\' ~ '\"' // alt
                    {
                    [self matchChar:'\\']; 


                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '!'))||(([input LA:1] >= '#') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }


                    }
                    break;
                case 3 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:372:13: '\\n' // alt
                    {

                                NSString *msg = @"\\n in string";
                                NoViableAltException *e = [NoViableAltException newException:0 state:0 stream:input];
                                [group.errMgr groupLexerError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
                                


                    [self matchChar:'\n']; 


                    }
                    break;
                case 4 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:378:13: ~ ( '\\\\' | '\"' | '\\n' ) // alt
                    {
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '\t'))||(([input LA:1] >= 0x000B) && ([input LA:1] <= '!'))||(([input LA:1] >= '#') && ([input LA:1] <= '['))||(([input LA:1] >= ']') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }


                    }
                    break;

                default :
                    goto loop2;
            }
        } while (YES);
        loop2: ;


        [self matchChar:'"']; 



                NSString *txt = [self.text  stringByReplacingOccurrencesOfString:@"\\\\\"" withString:@"\""];
                [self setText:txt];
                


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "STRING" */

// $ANTLR start "BIGSTRING_NO_NL"
- (void) mBIGSTRING_NO_NL
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = BIGSTRING_NO_NL;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:388:5: ( '<%' ( options {greedy=false; } : . )* '%>' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:388:9: '<%' ( options {greedy=false; } : . )* '%>' // alt
        {
        [self matchString:@"<%"]; 



        do {
            NSInteger alt3=2;
            NSInteger LA3_0 = [input LA:1];
            if ( (LA3_0=='%') ) {
                NSInteger LA3_1 = [input LA:2];
                if ( (LA3_1=='>') ) {
                    alt3=2;
                }
                else if ( ((LA3_1 >= 0x0000 && LA3_1 <= '=')||(LA3_1 >= '?' && LA3_1 <= 0xFFFF)) ) {
                    alt3=1;
                }


            }
            else if ( ((LA3_0 >= 0x0000 && LA3_0 <= '$')||(LA3_0 >= '&' && LA3_0 <= 0xFFFF)) ) {
                alt3=1;
            }


            switch (alt3) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:388:41: . // alt
                    {
                    [self matchAny]; 


                    }
                    break;

                default :
                    goto loop3;
            }
        } while (YES);
        loop3: ;


        [self matchString:@"%>"]; 



        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "BIGSTRING_NO_NL" */

// $ANTLR start "BIGSTRING"
- (void) mBIGSTRING
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = BIGSTRING;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:392:5: ( '<<' ( options {greedy=false; } : '\\\\' '>' | '\\\\' ~ '>' |~ '\\\\' )* '>>' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:392:9: '<<' ( options {greedy=false; } : '\\\\' '>' | '\\\\' ~ '>' |~ '\\\\' )* '>>' // alt
        {
        [self matchString:@"<<"]; 



        do {
            NSInteger alt4=4;
            NSInteger LA4_0 = [input LA:1];
            if ( (LA4_0=='>') ) {
                NSInteger LA4_1 = [input LA:2];
                if ( (LA4_1=='>') ) {
                    alt4=4;
                }
                else if ( ((LA4_1 >= 0x0000 && LA4_1 <= '=')||(LA4_1 >= '?' && LA4_1 <= 0xFFFF)) ) {
                    alt4=3;
                }


            }
            else if ( (LA4_0=='\\') ) {
                NSInteger LA4_2 = [input LA:2];
                if ( (LA4_2=='>') ) {
                    alt4=1;
                }
                else if ( ((LA4_2 >= 0x0000 && LA4_2 <= '=')||(LA4_2 >= '?' && LA4_2 <= 0xFFFF)) ) {
                    alt4=2;
                }


            }
            else if ( ((LA4_0 >= 0x0000 && LA4_0 <= '=')||(LA4_0 >= '?' && LA4_0 <= '[')||(LA4_0 >= ']' && LA4_0 <= 0xFFFF)) ) {
                alt4=3;
            }


            switch (alt4) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:394:13: '\\\\' '>' // alt
                    {
                    [self matchChar:'\\']; 


                    [self matchChar:'>']; 


                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:395:13: '\\\\' ~ '>' // alt
                    {
                    [self matchChar:'\\']; 


                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '='))||(([input LA:1] >= '?') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }


                    }
                    break;
                case 3 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:396:13: ~ '\\\\' // alt
                    {
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '['))||(([input LA:1] >= ']') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }


                    }
                    break;

                default :
                    goto loop4;
            }
        } while (YES);
        loop4: ;


        [self matchString:@">>"]; 




                NSString *txt = [self.text stringByReplacingOccurrencesOfString:@"\\\\>" withString:@">"];
                [self setText:txt];
                


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "BIGSTRING" */

// $ANTLR start "ANONYMOUS_TEMPLATE"
- (void) mANONYMOUS_TEMPLATE
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = ANONYMOUS_TEMPLATE;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:406:5: ( '{' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:406:9: '{' // alt
        {
        [self matchChar:'{']; 



                STToken *templateToken = [STToken newToken:input
                                                      Type:ANONYMOUS_TEMPLATE
                                                   Channel:0
                                                     Start:input.index
                                                      Stop:input.index];
                STLexer *lexer = [STLexer newSTLexer:group.errMgr
                                               input:input
                                       templateToken:templateToken
                                  delimiterStartChar:group.delimiterStartChar
                                   delimiterStopChar:group.delimiterStopChar];
                [lexer setSubtemplateDepth:1];
                STToken *t = [lexer nextToken];
                while ( [lexer subtemplateDepth] >= 1 || t.type != STLexer.RCURLY ) {
                    if ( t.type == STLexer.EOF_TYPE ) {
                        MismatchedTokenException *e = [MismatchedTokenException newException:'}' Stream:input];
                        NSString *msg = @"missing final '}' in {...} anonymous template";
                        [group.errMgr groupLexerError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
                        break;
                    }
                    t = [lexer nextToken];
                }
                


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "ANONYMOUS_TEMPLATE" */

// $ANTLR start "COMMENT"
- (void) mCOMMENT
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = COMMENT;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:435:5: ( '/*' ( options {greedy=false; } : . )* '*/' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:435:9: '/*' ( options {greedy=false; } : . )* '*/' // alt
        {
        [self matchString:@"/*"]; 



        do {
            NSInteger alt5=2;
            NSInteger LA5_0 = [input LA:1];
            if ( (LA5_0=='*') ) {
                NSInteger LA5_1 = [input LA:2];
                if ( (LA5_1=='/') ) {
                    alt5=2;
                }
                else if ( ((LA5_1 >= 0x0000 && LA5_1 <= '.')||(LA5_1 >= '0' && LA5_1 <= 0xFFFF)) ) {
                    alt5=1;
                }


            }
            else if ( ((LA5_0 >= 0x0000 && LA5_0 <= ')')||(LA5_0 >= '+' && LA5_0 <= 0xFFFF)) ) {
                alt5=1;
            }


            switch (alt5) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:435:42: . // alt
                    {
                    [self matchAny]; 


                    }
                    break;

                default :
                    goto loop5;
            }
        } while (YES);
        loop5: ;


        [self matchString:@"*/"]; 



         [self skip]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "COMMENT" */

// $ANTLR start "LINE_COMMENT"
- (void) mLINE_COMMENT
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = LINE_COMMENT;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:439:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:439:9: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' // alt
        {
        [self matchString:@"//"]; 



        do {
            NSInteger alt6=2;
            NSInteger LA6_0 = [input LA:1];
            if ( ((LA6_0 >= 0x0000 && LA6_0 <= '\t')||(LA6_0 >= 0x000B && LA6_0 <= '\f')||(LA6_0 >= 0x000E && LA6_0 <= 0xFFFF)) ) {
                alt6=1;
            }


            switch (alt6) {
                case 1 : ;
                    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g: // alt
                    {
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '\t'))||(([input LA:1] >= 0x000B) && ([input LA:1] <= '\f'))||(([input LA:1] >= 0x000E) && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }


                    }
                    break;

                default :
                    goto loop6;
            }
        } while (YES);
        loop6: ;


        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:439:28: ( '\\r' )? // block
        NSInteger alt7=2;
        NSInteger LA7_0 = [input LA:1];

        if ( (LA7_0=='\r') ) {
            alt7=1;
        }
        switch (alt7) {
            case 1 : ;
                // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:439:28: '\\r' // alt
                {
                [self matchChar:'\r']; 


                }
                break;

        }


        [self matchChar:'\n']; 


         [self skip]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "LINE_COMMENT" */

// $ANTLR start "WS"
- (void) mWS
{
    //
    /* my ruleScopeSetUp */
    /* Terence's stuff */

    @try {
        NSInteger _type = WS;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:442:5: ( ( ' ' | '\\r' | '\\t' | '\\n' ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:442:9: ( ' ' | '\\r' | '\\t' | '\\n' ) // alt
        {
        if ((([input LA:1] >= '\t') && ([input LA:1] <= '\n'))||[input LA:1] == '\r'||[input LA:1] == ' ') {
            [input consume];
        } else {
            MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
            [self recover:mse];
            @throw mse;
        }


         [self skip]; 


        }

        // token+rule list labels

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* Terence's stuff */

    }
    return;
}
/* $ANTLR end "WS" */

- (void) mTokens
{
    // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:8: ( T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | ID | STRING | BIGSTRING_NO_NL | BIGSTRING | ANONYMOUS_TEMPLATE | COMMENT | LINE_COMMENT | WS ) //ruleblock
    NSInteger alt8=23;
    unichar charLA8 = [input LA:1];
    switch (charLA8) {
        case '(': ;
            {
            alt8=1;
            }
            break;
        case ')': ;
            {
            alt8=2;
            }
            break;
        case ',': ;
            {
            alt8=3;
            }
            break;
        case '.': ;
            {
            alt8=4;
            }
            break;
        case ':': ;
            {
            NSInteger LA8_5 = [input LA:2];

            if ( (LA8_5==':') ) {
                alt8=6;
            }
            else {
                alt8 = 5;
            }
            }
            break;
        case ';': ;
            {
            alt8=7;
            }
            break;
        case '=': ;
            {
            alt8=8;
            }
            break;
        case '@': ;
            {
            alt8=9;
            }
            break;
        case '[': ;
            {
            alt8=10;
            }
            break;
        case ']': ;
            {
            alt8=11;
            }
            break;
        case 'd': ;
            {
            NSInteger LA8_11 = [input LA:2];

            if ( (LA8_11=='e') ) {
                NSInteger LA8_22 = [input LA:3];

                if ( (LA8_22=='f') ) {
                    NSInteger LA8_29 = [input LA:4];

                    if ( (LA8_29=='a') ) {
                        NSInteger LA8_32 = [input LA:5];

                        if ( (LA8_32=='u') ) {
                            NSInteger LA8_36 = [input LA:6];

                            if ( (LA8_36=='l') ) {
                                NSInteger LA8_40 = [input LA:7];

                                if ( (LA8_40=='t') ) {
                                    NSInteger LA8_44 = [input LA:8];

                                    if ( (LA8_44=='-'||(LA8_44 >= '0' && LA8_44 <= '9')||(LA8_44 >= 'A' && LA8_44 <= 'Z')||LA8_44=='_'||(LA8_44 >= 'a' && LA8_44 <= 'z')) ) {
                                        alt8=16;
                                    }
                                    else {
                                        alt8 = 12;
                                    }
                                }
                                else {
                                    alt8 = 16;
                                }
                            }
                            else {
                                alt8 = 16;
                            }
                        }
                        else {
                            alt8 = 16;
                        }
                    }
                    else {
                        alt8 = 16;
                    }
                }
                else {
                    alt8 = 16;
                }
            }
            else {
                alt8 = 16;
            }
            }
            break;
        case 'g': ;
            {
            NSInteger LA8_12 = [input LA:2];

            if ( (LA8_12=='r') ) {
                NSInteger LA8_23 = [input LA:3];

                if ( (LA8_23=='o') ) {
                    NSInteger LA8_30 = [input LA:4];

                    if ( (LA8_30=='u') ) {
                        NSInteger LA8_33 = [input LA:5];

                        if ( (LA8_33=='p') ) {
                            NSInteger LA8_37 = [input LA:6];

                            if ( (LA8_37=='-'||(LA8_37 >= '0' && LA8_37 <= '9')||(LA8_37 >= 'A' && LA8_37 <= 'Z')||LA8_37=='_'||(LA8_37 >= 'a' && LA8_37 <= 'z')) ) {
                                alt8=16;
                            }
                            else {
                                alt8 = 13;
                            }
                        }
                        else {
                            alt8 = 16;
                        }
                    }
                    else {
                        alt8 = 16;
                    }
                }
                else {
                    alt8 = 16;
                }
            }
            else {
                alt8 = 16;
            }
            }
            break;
        case 'i': ;
            {
            NSInteger LA8_13 = [input LA:2];

            if ( (LA8_13=='m') ) {
                NSInteger LA8_24 = [input LA:3];

                if ( (LA8_24=='p') ) {
                    unichar charLA8 = [input LA:4];
                    switch (charLA8) {
                        case 'l': ;
                            {
                            NSInteger LA8_34 = [input LA:5];

                            if ( (LA8_34=='e') ) {
                                NSInteger LA8_38 = [input LA:6];

                                if ( (LA8_38=='m') ) {
                                    NSInteger LA8_42 = [input LA:7];

                                    if ( (LA8_42=='e') ) {
                                        NSInteger LA8_45 = [input LA:8];

                                        if ( (LA8_45=='n') ) {
                                            NSInteger LA8_48 = [input LA:9];

                                            if ( (LA8_48=='t') ) {
                                                NSInteger LA8_49 = [input LA:10];

                                                if ( (LA8_49=='s') ) {
                                                    NSInteger LA8_50 = [input LA:11];

                                                    if ( (LA8_50=='-'||(LA8_50 >= '0' && LA8_50 <= '9')||(LA8_50 >= 'A' && LA8_50 <= 'Z')||LA8_50=='_'||(LA8_50 >= 'a' && LA8_50 <= 'z')) ) {
                                                        alt8=16;
                                                    }
                                                    else {
                                                        alt8 = 14;
                                                    }
                                                }
                                                else {
                                                    alt8 = 16;
                                                }
                                            }
                                            else {
                                                alt8 = 16;
                                            }
                                        }
                                        else {
                                            alt8 = 16;
                                        }
                                    }
                                    else {
                                        alt8 = 16;
                                    }
                                }
                                else {
                                    alt8 = 16;
                                }
                            }
                            else {
                                alt8 = 16;
                            }
                            }
                            break;
                        case 'o': ;
                            {
                            NSInteger LA8_35 = [input LA:5];

                            if ( (LA8_35=='r') ) {
                                NSInteger LA8_39 = [input LA:6];

                                if ( (LA8_39=='t') ) {
                                    NSInteger LA8_43 = [input LA:7];

                                    if ( (LA8_43=='-'||(LA8_43 >= '0' && LA8_43 <= '9')||(LA8_43 >= 'A' && LA8_43 <= 'Z')||LA8_43=='_'||(LA8_43 >= 'a' && LA8_43 <= 'z')) ) {
                                        alt8=16;
                                    }
                                    else {
                                        alt8 = 15;
                                    }
                                }
                                else {
                                    alt8 = 16;
                                }
                            }
                            else {
                                alt8 = 16;
                            }
                            }
                            break;

                    default: ;
                        alt8 = 16;
                    }

                }
                else {
                    alt8 = 16;
                }
            }
            else {
                alt8 = 16;
            }
            }
            break;
        case 'A': ;
        case 'B': ;
        case 'C': ;
        case 'D': ;
        case 'E': ;
        case 'F': ;
        case 'G': ;
        case 'H': ;
        case 'I': ;
        case 'J': ;
        case 'K': ;
        case 'L': ;
        case 'M': ;
        case 'N': ;
        case 'O': ;
        case 'P': ;
        case 'Q': ;
        case 'R': ;
        case 'S': ;
        case 'T': ;
        case 'U': ;
        case 'V': ;
        case 'W': ;
        case 'X': ;
        case 'Y': ;
        case 'Z': ;
        case '_': ;
        case 'a': ;
        case 'b': ;
        case 'c': ;
        case 'e': ;
        case 'f': ;
        case 'h': ;
        case 'j': ;
        case 'k': ;
        case 'l': ;
        case 'm': ;
        case 'n': ;
        case 'o': ;
        case 'p': ;
        case 'q': ;
        case 'r': ;
        case 's': ;
        case 't': ;
        case 'u': ;
        case 'v': ;
        case 'w': ;
        case 'x': ;
        case 'y': ;
        case 'z': ;
            {
            alt8=16;
            }
            break;
        case '"': ;
            {
            alt8=17;
            }
            break;
        case '<': ;
            {
            NSInteger LA8_16 = [input LA:2];

            if ( (LA8_16=='%') ) {
                alt8=18;
            }
            else if ( (LA8_16=='<') ) {
                alt8=19;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:8 state:16 stream:input];
                nvae.c = LA8_16;
                @throw nvae;

            }
            }
            break;
        case '{': ;
            {
            alt8=20;
            }
            break;
        case '/': ;
            {
            NSInteger LA8_18 = [input LA:2];

            if ( (LA8_18=='*') ) {
                alt8=21;
            }
            else if ( (LA8_18=='/') ) {
                alt8=22;
            }
            else {
                NoViableAltException *nvae = [NoViableAltException newException:8 state:18 stream:input];
                nvae.c = LA8_18;
                @throw nvae;

            }
            }
            break;
        case '\t': ;
        case '\n': ;
        case '\r': ;
        case ' ': ;
            {
            alt8=23;
            }
            break;

    default: ;
        NoViableAltException *nvae = [NoViableAltException newException:8 state:0 stream:input];
        nvae.c = charLA8;
        @throw nvae;

    }

    switch (alt8) {
        case 1 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:10: T__14 // alt
            {
            [self mT__14]; 



            }
            break;
        case 2 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:16: T__15 // alt
            {
            [self mT__15]; 



            }
            break;
        case 3 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:22: T__16 // alt
            {
            [self mT__16]; 



            }
            break;
        case 4 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:28: T__17 // alt
            {
            [self mT__17]; 



            }
            break;
        case 5 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:34: T__18 // alt
            {
            [self mT__18]; 



            }
            break;
        case 6 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:40: T__19 // alt
            {
            [self mT__19]; 



            }
            break;
        case 7 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:46: T__20 // alt
            {
            [self mT__20]; 



            }
            break;
        case 8 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:52: T__21 // alt
            {
            [self mT__21]; 



            }
            break;
        case 9 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:58: T__22 // alt
            {
            [self mT__22]; 



            }
            break;
        case 10 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:64: T__23 // alt
            {
            [self mT__23]; 



            }
            break;
        case 11 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:70: T__24 // alt
            {
            [self mT__24]; 



            }
            break;
        case 12 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:76: T__25 // alt
            {
            [self mT__25]; 



            }
            break;
        case 13 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:82: T__26 // alt
            {
            [self mT__26]; 



            }
            break;
        case 14 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:88: T__27 // alt
            {
            [self mT__27]; 



            }
            break;
        case 15 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:94: T__28 // alt
            {
            [self mT__28]; 



            }
            break;
        case 16 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:100: ID // alt
            {
            [self mID]; 



            }
            break;
        case 17 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:103: STRING // alt
            {
            [self mSTRING]; 



            }
            break;
        case 18 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:110: BIGSTRING_NO_NL // alt
            {
            [self mBIGSTRING_NO_NL]; 



            }
            break;
        case 19 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:126: BIGSTRING // alt
            {
            [self mBIGSTRING]; 



            }
            break;
        case 20 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:136: ANONYMOUS_TEMPLATE // alt
            {
            [self mANONYMOUS_TEMPLATE]; 



            }
            break;
        case 21 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:155: COMMENT // alt
            {
            [self mCOMMENT]; 



            }
            break;
        case 22 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:163: LINE_COMMENT // alt
            {
            [self mLINE_COMMENT]; 



            }
            break;
        case 23 : ;
            // /Users/acondit/source/antlr3/acondit_localhost/code/ST4/objc/main/compiler/Group.g:1:176: WS // alt
            {
            [self mWS]; 



            }
            break;

    }

}

@end /* end of GroupLexer implementation line 397 */