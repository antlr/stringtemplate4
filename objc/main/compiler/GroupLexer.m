/** \file
 *  This OBJC source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g
 *     -                            On : 2012-02-02 11:03:28
 *     -                 for the lexer : GroupLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
 *
 *
*/
// $ANTLR 3.4 /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g 2012-02-02 11:03:28


/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#import "GroupLexer.h"
/* ----------------------------------------- */


/* ============================================================================= */
/* =============================================================================
 * Start of recognizer
 */
#pragma mark Cyclic DFA implementation start DFA8
@implementation DFA8
const static NSInteger dfa8_eot[61] =
    {-1,-1,-1,-1,-1,21,-1,-1,-1,-1,-1,14,14,14,-1,-1,-1,-1,-1,-1,-1,-1,14,
     14,14,-1,-1,-1,-1,14,14,14,14,14,14,14,14,14,14,14,45,14,14,14,14,-1,
     14,51,52,14,14,-1,-1,14,14,14,14,59,60,-1,-1};
const static NSInteger dfa8_eof[61] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static unichar dfa8_min[61] =
    {9,0,0,0,0,58,0,0,0,0,0,101,114,109,0,0,37,0,42,0,0,0,102,111,112,0,
     0,0,0,97,105,117,108,117,109,112,101,114,108,105,45,109,116,116,116,
     0,101,45,45,101,110,0,0,114,116,115,115,45,45,0,0};
const static unichar dfa8_max[61] =
    {123,0,0,0,0,58,0,0,0,0,0,101,114,109,0,0,60,0,47,0,0,0,108,111,112,
     0,0,0,0,97,105,117,111,117,109,112,101,114,108,105,122,109,116,116,
     116,0,101,122,122,101,110,0,0,114,116,115,115,122,122,0,0};
const static NSInteger dfa8_accept[61] =
    {-1,1,2,3,4,-1,7,8,9,10,11,-1,-1,-1,17,18,-1,21,-1,24,6,5,-1,-1,-1,19,
     20,22,23,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,14,-1,-1,-1,
     -1,-1,16,12,-1,-1,-1,-1,-1,-1,13,15};
const static NSInteger dfa8_special[61] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa8_transition[] = {};
const static NSInteger dfa8_transition0[] = {41};
const static NSInteger dfa8_transition1[] = {58};
const static NSInteger dfa8_transition2[] = {25, -1, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 26};
const static NSInteger dfa8_transition3[] = {14, -1, -1, 14, 14, 14, 14, 
 14, 14, 14, 14, 14, 14, -1, -1, -1, -1, -1, -1, -1, 14, 14, 14, 14, 14, 
 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 
 14, 14, 14, -1, -1, -1, -1, 14, -1, 14, 14, 14, 14, 14, 14, 14, 14, 14, 
 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14};
const static NSInteger dfa8_transition4[] = {54};
const static NSInteger dfa8_transition5[] = {36, -1, -1, 37};
const static NSInteger dfa8_transition6[] = {56};
const static NSInteger dfa8_transition7[] = {32};
const static NSInteger dfa8_transition8[] = {46};
const static NSInteger dfa8_transition9[] = {50};
const static NSInteger dfa8_transition10[] = {57};
const static NSInteger dfa8_transition11[] = {55};
const static NSInteger dfa8_transition12[] = {53};
const static NSInteger dfa8_transition13[] = {49};
const static NSInteger dfa8_transition14[] = {44};
const static NSInteger dfa8_transition15[] = {39};
const static NSInteger dfa8_transition16[] = {34};
const static NSInteger dfa8_transition17[] = {40};
const static NSInteger dfa8_transition18[] = {35};
const static NSInteger dfa8_transition19[] = {31};
const static NSInteger dfa8_transition20[] = {20};
const static NSInteger dfa8_transition21[] = {22};
const static NSInteger dfa8_transition22[] = {47};
const static NSInteger dfa8_transition23[] = {42};
const static NSInteger dfa8_transition24[] = {29, -1, -1, -1, -1, -1, 30};
const static NSInteger dfa8_transition25[] = {19, 19, -1, -1, 19, -1, -1, 
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 19, -1, 
 15, -1, -1, -1, -1, -1, 1, 2, -1, -1, 3, -1, 4, 18, -1, -1, -1, -1, -1, 
 -1, -1, -1, -1, -1, 5, 6, 16, 7, -1, -1, 8, 14, 14, 14, 14, 14, 14, 14, 
 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 
 14, 9, -1, 10, -1, 14, -1, 14, 14, 14, 11, 14, 14, 12, 14, 13, 14, 14, 
 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 17};
const static NSInteger dfa8_transition26[] = {24};
const static NSInteger dfa8_transition27[] = {33};
const static NSInteger dfa8_transition28[] = {38};
const static NSInteger dfa8_transition29[] = {43};
const static NSInteger dfa8_transition30[] = {48};
const static NSInteger dfa8_transition31[] = {27, -1, -1, -1, -1, 28};
const static NSInteger dfa8_transition32[] = {23};


+ (id) newDFA8WithRecognizer:(BaseRecognizer *)aRecognizer
{
    return [[[DFA8 alloc] initWithRecognizer:aRecognizer] retain];
}

- (id) initWithRecognizer:(BaseRecognizer *) theRecognizer
{
    self = [super initWithRecognizer:theRecognizer];
    if ( self != nil ) {
        decisionNumber = 8;
        eot = dfa8_eot;
        eof = dfa8_eof;
        min = dfa8_min;
        max = dfa8_max;
        accept = dfa8_accept;
        special = dfa8_special;
        if (!(transition = calloc(61, sizeof(void*)))) {
            [self release];
            return nil;
        }
        len = 61;
        transition[0] = dfa8_transition25;




        transition[1] = dfa8_transition20;





        transition[2] = dfa8_transition21;
        transition[3] = dfa8_transition32;
        transition[4] = dfa8_transition26;


        transition[5] = dfa8_transition2;

        transition[6] = dfa8_transition31;



        transition[7] = dfa8_transition24;
        transition[8] = dfa8_transition19;
        transition[9] = dfa8_transition7;




        transition[10] = dfa8_transition27;
        transition[11] = dfa8_transition16;
        transition[12] = dfa8_transition18;
        transition[13] = dfa8_transition5;
        transition[14] = dfa8_transition28;
        transition[15] = dfa8_transition15;
        transition[16] = dfa8_transition17;
        transition[17] = dfa8_transition0;
        transition[18] = dfa8_transition23;
        transition[19] = dfa8_transition29;
        transition[20] = dfa8_transition14;
        transition[21] = dfa8_transition3;
        transition[22] = dfa8_transition8;
        transition[23] = dfa8_transition22;
        transition[24] = dfa8_transition30;
        transition[25] = dfa8_transition13;

        transition[26] = dfa8_transition9;
        transition[27] = dfa8_transition3;
        transition[28] = dfa8_transition3;
        transition[29] = dfa8_transition12;
        transition[30] = dfa8_transition4;


        transition[31] = dfa8_transition11;
        transition[32] = dfa8_transition6;
        transition[33] = dfa8_transition10;
        transition[34] = dfa8_transition1;
        transition[35] = dfa8_transition3;
        transition[36] = dfa8_transition3;


    }
    return self;
}

- (void) dealloc
{
    free(transition);
    [super dealloc];
}

- (NSString *) description
{
    return @"1:1: Tokens : ( T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | T__29 | ID | STRING | BIGSTRING_NO_NL | BIGSTRING | ANONYMOUS_TEMPLATE | COMMENT | LINE_COMMENT | WS );";
}


@end /* end DFA8 implementation */

#pragma mark Cyclic DFA implementation end DFA8



/** As per Terence: No returns for lexer rules! */
@implementation GroupLexer // line 330

+ (void) initialize
{
    [BaseRecognizer setGrammarFileName:@"/Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g"];
}

+ (NSString *) tokenNameForType:(NSInteger)aTokenType
{
    return [[self getTokenNames] objectAtIndex:aTokenType];
}

+ (GroupLexer *)newGroupLexerWithCharStream:(id<CharStream>)anInput
{
    return [[GroupLexer alloc] initWithCharStream:anInput];
}

- (id) initWithCharStream:(id<CharStream>)anInput
{
    self = [super initWithCharStream:anInput State:[RecognizerSharedState newRecognizerSharedStateWithRuleLen:25+1]];
    if ( self != nil ) {
        dfa8 = [DFA8 newDFA8WithRecognizer:self];
    }
    return self;
}

- (void) dealloc
{
    [dfa8 release];
    [super dealloc];
}

/* ObjC Start of actions.lexer.methods */

@synthesize group;

- (void) reportError:(RecognitionException *)e
{
    NSString *msg = nil;
    if ( [e isKindOfClass:[NoViableAltException class]] ) {
#pragma error fix formatting
        msg = [NSString stringWithFormat:@"invalid character '%C'", [input LA:1]];
    }
    else if ( [e isKindOfClass:[MismatchedTokenException class]] && ((MismatchedTokenException *)e).expecting=='"' ) {
        msg = @"unterminated string";
    }
    else {
        msg = [self getErrorMessage:e TokenNames:[self getTokenNames]];
    }
    [group.errMgr groupSyntaxError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
}

- (NSString *) getSourceName
{
    return [super getSourceName];
}


/* ObjC end of actions.lexer.methods */
/* ObjC start methods() */
/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "T__14"
- (void) mT__14
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__14;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:79:7: ( '(' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:79:9: '(' // alt
        {


        [self matchChar:'(']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__14" */
// $ANTLR start "T__15"
- (void) mT__15
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__15;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:80:7: ( ')' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:80:9: ')' // alt
        {


        [self matchChar:')']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__15" */
// $ANTLR start "T__16"
- (void) mT__16
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__16;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:81:7: ( ',' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:81:9: ',' // alt
        {


        [self matchChar:',']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__16" */
// $ANTLR start "T__17"
- (void) mT__17
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__17;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:82:7: ( '.' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:82:9: '.' // alt
        {


        [self matchChar:'.']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__17" */
// $ANTLR start "T__18"
- (void) mT__18
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__18;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:83:7: ( ':' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:83:9: ':' // alt
        {


        [self matchChar:':']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__18" */
// $ANTLR start "T__19"
- (void) mT__19
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__19;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:84:7: ( '::=' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:84:9: '::=' // alt
        {


        [self matchString:@"::="]; 


         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__19" */
// $ANTLR start "T__20"
- (void) mT__20
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__20;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:85:7: ( ';' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:85:9: ';' // alt
        {


        [self matchChar:';']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__20" */
// $ANTLR start "T__21"
- (void) mT__21
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__21;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:86:7: ( '=' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:86:9: '=' // alt
        {


        [self matchChar:'=']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__21" */
// $ANTLR start "T__22"
- (void) mT__22
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__22;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:87:7: ( '@' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:87:9: '@' // alt
        {


        [self matchChar:'@']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__22" */
// $ANTLR start "T__23"
- (void) mT__23
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__23;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:88:7: ( '[' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:88:9: '[' // alt
        {


        [self matchChar:'[']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__23" */
// $ANTLR start "T__24"
- (void) mT__24
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__24;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:89:7: ( ']' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:89:9: ']' // alt
        {


        [self matchChar:']']; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__24" */
// $ANTLR start "T__25"
- (void) mT__25
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__25;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:90:7: ( 'default' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:90:9: 'default' // alt
        {


        [self matchString:@"default"]; 


         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__25" */
// $ANTLR start "T__26"
- (void) mT__26
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__26;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:91:7: ( 'delimiters' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:91:9: 'delimiters' // alt
        {


        [self matchString:@"delimiters"]; 


         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__26" */
// $ANTLR start "T__27"
- (void) mT__27
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__27;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:92:7: ( 'group' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:92:9: 'group' // alt
        {


        [self matchString:@"group"]; 


         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__27" */
// $ANTLR start "T__28"
- (void) mT__28
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__28;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:93:7: ( 'implements' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:93:9: 'implements' // alt
        {


        [self matchString:@"implements"]; 


         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__28" */
// $ANTLR start "T__29"
- (void) mT__29
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = T__29;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:94:7: ( 'import' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:94:9: 'import' // alt
        {


        [self matchString:@"import"]; 


         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "T__29" */
// $ANTLR start "ID"
- (void) mID
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = ID;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:374:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:374:9: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '-' | '_' )* // alt
        {

        if ((([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
            [input consume];
        } else {
            MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
            [self recover:mse];
            @throw mse;
        }

         

        do {
            NSInteger alt1=2;
            NSInteger LA1_0 = [input LA:1];
            if ( (LA1_0=='-'||(LA1_0 >= '0' && LA1_0 <= '9')||(LA1_0 >= 'A' && LA1_0 <= 'Z')||LA1_0=='_'||(LA1_0 >= 'a' && LA1_0 <= 'z')) ) {
                alt1=1;
            }


            switch (alt1) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g: // alt
                    {

                    if ([input LA:1] == '-'||(([input LA:1] >= '0') && ([input LA:1] <= '9'))||(([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }

                     
                    }
                    break;

                default :
                    goto loop1;
            }
        } while (YES);
        loop1: ;

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "ID" */
// $ANTLR start "STRING"
- (void) mSTRING
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = STRING;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:378:5: ( '\"' ( '\\\\' '\"' | '\\\\' ~ '\"' | '\\n' |~ ( '\\\\' | '\"' | '\\n' ) )* '\"' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:378:9: '\"' ( '\\\\' '\"' | '\\\\' ~ '\"' | '\\n' |~ ( '\\\\' | '\"' | '\\n' ) )* '\"' // alt
        {


        [self matchChar:'"']; 

         

        do {
            NSInteger alt2=5;
            NSInteger LA2_0 = [input LA:1];
            if ( (LA2_0=='\\') ) {
                NSInteger LA2_2 = [input LA:2];
                if ( (LA2_2=='"') ) {
                    alt2=1;
                }
                else if ( ((LA2_2 >= 0x0000 && LA2_2 <= '!')||(LA2_2 >= '#' && LA2_2 <= 0xFFFF)) ) {
                    alt2=2;
                }


            }
            else if ( (LA2_0=='\n') ) {
                alt2=3;
            }
            else if ( ((LA2_0 >= 0x0000 && LA2_0 <= '\t')||(LA2_0 >= 0x000B && LA2_0 <= '!')||(LA2_0 >= '#' && LA2_0 <= '[')||(LA2_0 >= ']' && LA2_0 <= 0xFFFF)) ) {
                alt2=4;
            }


            switch (alt2) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:379:13: '\\\\' '\"' // alt
                    {


                    [self matchChar:'\\']; 

                     

                    [self matchChar:'"']; 

                     
                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:380:13: '\\\\' ~ '\"' // alt
                    {


                    [self matchChar:'\\']; 

                     
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '!'))||(([input LA:1] >= '#') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }

                     
                    }
                    break;
                case 3 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:381:13: '\\n' // alt
                    {



                                NSString *msg = @"\\n in string";
                                NoViableAltException *e = [NoViableAltException newException:0 state:0 stream:input];
                                [group.errMgr groupLexerError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
                                

                     

                    [self matchChar:'\n']; 

                     
                    }
                    break;
                case 4 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:387:13: ~ ( '\\\\' | '\"' | '\\n' ) // alt
                    {

                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '\t'))||(([input LA:1] >= 0x000B) && ([input LA:1] <= '!'))||(([input LA:1] >= '#') && ([input LA:1] <= '['))||(([input LA:1] >= ']') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }

                     
                    }
                    break;

                default :
                    goto loop2;
            }
        } while (YES);
        loop2: ;

         

        [self matchChar:'"']; 

         


                NSString *txt = [self.text  stringByReplacingOccurrencesOfString:@"\\\\\"" withString:@"\""];
                [self setText:txt];
                

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "STRING" */
// $ANTLR start "BIGSTRING_NO_NL"
- (void) mBIGSTRING_NO_NL
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = BIGSTRING_NO_NL;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:397:5: ( '<%' ( options {greedy=false; } : . )* '%>' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:397:9: '<%' ( options {greedy=false; } : . )* '%>' // alt
        {


        [self matchString:@"<%"]; 


         

        do {
            NSInteger alt3=2;
            NSInteger LA3_0 = [input LA:1];
            if ( (LA3_0=='%') ) {
                NSInteger LA3_1 = [input LA:2];
                if ( (LA3_1=='>') ) {
                    alt3=2;
                }
                else if ( ((LA3_1 >= 0x0000 && LA3_1 <= '=')||(LA3_1 >= '?' && LA3_1 <= 0xFFFF)) ) {
                    alt3=1;
                }


            }
            else if ( ((LA3_0 >= 0x0000 && LA3_0 <= '$')||(LA3_0 >= '&' && LA3_0 <= 0xFFFF)) ) {
                alt3=1;
            }


            switch (alt3) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:397:41: . // alt
                    {

                    [self matchAny]; 

                     
                    }
                    break;

                default :
                    goto loop3;
            }
        } while (YES);
        loop3: ;

         

        [self matchString:@"%>"]; 


         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "BIGSTRING_NO_NL" */
// $ANTLR start "BIGSTRING"
- (void) mBIGSTRING
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = BIGSTRING;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:401:5: ( '<<' ( options {greedy=false; } : '\\\\' '>' | '\\\\' ~ '>' |~ '\\\\' )* '>>' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:401:9: '<<' ( options {greedy=false; } : '\\\\' '>' | '\\\\' ~ '>' |~ '\\\\' )* '>>' // alt
        {


        [self matchString:@"<<"]; 


         

        do {
            NSInteger alt4=4;
            NSInteger LA4_0 = [input LA:1];
            if ( (LA4_0=='>') ) {
                NSInteger LA4_1 = [input LA:2];
                if ( (LA4_1=='>') ) {
                    alt4=4;
                }
                else if ( ((LA4_1 >= 0x0000 && LA4_1 <= '=')||(LA4_1 >= '?' && LA4_1 <= 0xFFFF)) ) {
                    alt4=3;
                }


            }
            else if ( (LA4_0=='\\') ) {
                NSInteger LA4_2 = [input LA:2];
                if ( (LA4_2=='>') ) {
                    alt4=1;
                }
                else if ( ((LA4_2 >= 0x0000 && LA4_2 <= '=')||(LA4_2 >= '?' && LA4_2 <= 0xFFFF)) ) {
                    alt4=2;
                }


            }
            else if ( ((LA4_0 >= 0x0000 && LA4_0 <= '=')||(LA4_0 >= '?' && LA4_0 <= '[')||(LA4_0 >= ']' && LA4_0 <= 0xFFFF)) ) {
                alt4=3;
            }


            switch (alt4) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:403:13: '\\\\' '>' // alt
                    {


                    [self matchChar:'\\']; 

                     

                    [self matchChar:'>']; 

                     
                    }
                    break;
                case 2 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:404:13: '\\\\' ~ '>' // alt
                    {


                    [self matchChar:'\\']; 

                     
                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '='))||(([input LA:1] >= '?') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }

                     
                    }
                    break;
                case 3 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:405:13: ~ '\\\\' // alt
                    {

                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '['))||(([input LA:1] >= ']') && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }

                     
                    }
                    break;

                default :
                    goto loop4;
            }
        } while (YES);
        loop4: ;

         

        [self matchString:@">>"]; 


         


                NSString *txt = [self.text stringByReplacingOccurrencesOfString:@"\\\\>" withString:@">"];
                [self setText:txt];
                

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "BIGSTRING" */
// $ANTLR start "ANONYMOUS_TEMPLATE"
- (void) mANONYMOUS_TEMPLATE
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = ANONYMOUS_TEMPLATE;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:415:5: ( '{' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:415:9: '{' // alt
        {


        [self matchChar:'{']; 

         


                CommonToken *templateToken = [CommonToken newToken:input
                                                      Type:ANONYMOUS_TEMPLATE
                                                   Channel:0
                                                     Start:input.index
                                                      Stop:input.index];
                STLexer *lexer = [STLexer newSTLexer:group.errMgr
                                               input:input
                                       templateToken:templateToken
                                  delimiterStartChar:group.delimiterStartChar
                                   delimiterStopChar:group.delimiterStopChar];
                [lexer setSubtemplateDepth:1];
                CommonToken *t = [lexer nextToken];
                while ( [lexer subtemplateDepth] >= 1 || t.type != STLexer.RCURLY ) {
                    if ( t.type == STLexer.EOF_TYPE ) {
                        MismatchedTokenException *e = [MismatchedTokenException newException:'}' Stream:input];
                        NSString *msg = @"missing final '}' in {...} anonymous template";
                        [group.errMgr groupLexerError:SYNTAX_ERROR srcName:[self getSourceName] e:e msg:msg];
                        break;
                    }
                    t = [lexer nextToken];
                }
                

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "ANONYMOUS_TEMPLATE" */
// $ANTLR start "COMMENT"
- (void) mCOMMENT
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = COMMENT;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:444:5: ( '/*' ( options {greedy=false; } : . )* '*/' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:444:9: '/*' ( options {greedy=false; } : . )* '*/' // alt
        {


        [self matchString:@"/*"]; 


         

        do {
            NSInteger alt5=2;
            NSInteger LA5_0 = [input LA:1];
            if ( (LA5_0=='*') ) {
                NSInteger LA5_1 = [input LA:2];
                if ( (LA5_1=='/') ) {
                    alt5=2;
                }
                else if ( ((LA5_1 >= 0x0000 && LA5_1 <= '.')||(LA5_1 >= '0' && LA5_1 <= 0xFFFF)) ) {
                    alt5=1;
                }


            }
            else if ( ((LA5_0 >= 0x0000 && LA5_0 <= ')')||(LA5_0 >= '+' && LA5_0 <= 0xFFFF)) ) {
                alt5=1;
            }


            switch (alt5) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:444:42: . // alt
                    {

                    [self matchAny]; 

                     
                    }
                    break;

                default :
                    goto loop5;
            }
        } while (YES);
        loop5: ;

         

        [self matchString:@"*/"]; 


         

         [self skip]; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "COMMENT" */
// $ANTLR start "LINE_COMMENT"
- (void) mLINE_COMMENT
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = LINE_COMMENT;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:448:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:448:9: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' // alt
        {


        [self matchString:@"//"]; 


         

        do {
            NSInteger alt6=2;
            NSInteger LA6_0 = [input LA:1];
            if ( ((LA6_0 >= 0x0000 && LA6_0 <= '\t')||(LA6_0 >= 0x000B && LA6_0 <= '\f')||(LA6_0 >= 0x000E && LA6_0 <= 0xFFFF)) ) {
                alt6=1;
            }


            switch (alt6) {
                case 1 : ;
                    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g: // alt
                    {

                    if ((([input LA:1] >= 0x0000) && ([input LA:1] <= '\t'))||(([input LA:1] >= 0x000B) && ([input LA:1] <= '\f'))||(([input LA:1] >= 0x000E) && ([input LA:1] <= 0xFFFF))) {
                        [input consume];
                    } else {
                        MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
                        [self recover:mse];
                        @throw mse;
                    }

                     
                    }
                    break;

                default :
                    goto loop6;
            }
        } while (YES);
        loop6: ;

         
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:448:28: ( '\\r' )? // block
        NSInteger alt7=2;
        NSInteger LA7_0 = [input LA:1];

        if ( (LA7_0=='\r') ) {
            alt7=1;
        }
        switch (alt7) {
            case 1 : ;
                // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:448:28: '\\r' // alt
                {


                [self matchChar:'\r']; 

                 
                }
                break;

        }

         

        [self matchChar:'\n']; 

         

         [self skip]; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "LINE_COMMENT" */
// $ANTLR start "WS"
- (void) mWS
{
    //
    /* ruleScopeSetUp */

    /* ruleDeclarations */

    @try {
        NSInteger _type = WS;
        NSInteger _channel = TokenChannelDefault;
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:451:5: ( ( ' ' | '\\r' | '\\t' | '\\n' ) ) // ruleBlockSingleAlt
        // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:451:9: ( ' ' | '\\r' | '\\t' | '\\n' ) // alt
        {

        if ((([input LA:1] >= '\t') && ([input LA:1] <= '\n'))||[input LA:1] == '\r'||[input LA:1] == ' ') {
            [input consume];
        } else {
            MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
            [self recover:mse];
            @throw mse;
        }

         

         [self skip]; 

         
        }

        /* token+rule list labels */

        state.type = _type;
        state.channel = _channel;
    }
    @finally {
        //
        /* ruleScopeCleanUp */

    }
    return;
}
/* $ANTLR end "WS" */
- (void) mTokens
{
    // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:8: ( T__14 | T__15 | T__16 | T__17 | T__18 | T__19 | T__20 | T__21 | T__22 | T__23 | T__24 | T__25 | T__26 | T__27 | T__28 | T__29 | ID | STRING | BIGSTRING_NO_NL | BIGSTRING | ANONYMOUS_TEMPLATE | COMMENT | LINE_COMMENT | WS ) //ruleblock
    NSInteger alt8=24;
    alt8 = [dfa8 predict:input];
    switch (alt8) {
        case 1 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:10: T__14 // alt
            {


            [self mT__14]; 


             
            }
            break;
        case 2 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:16: T__15 // alt
            {


            [self mT__15]; 


             
            }
            break;
        case 3 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:22: T__16 // alt
            {


            [self mT__16]; 


             
            }
            break;
        case 4 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:28: T__17 // alt
            {


            [self mT__17]; 


             
            }
            break;
        case 5 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:34: T__18 // alt
            {


            [self mT__18]; 


             
            }
            break;
        case 6 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:40: T__19 // alt
            {


            [self mT__19]; 


             
            }
            break;
        case 7 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:46: T__20 // alt
            {


            [self mT__20]; 


             
            }
            break;
        case 8 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:52: T__21 // alt
            {


            [self mT__21]; 


             
            }
            break;
        case 9 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:58: T__22 // alt
            {


            [self mT__22]; 


             
            }
            break;
        case 10 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:64: T__23 // alt
            {


            [self mT__23]; 


             
            }
            break;
        case 11 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:70: T__24 // alt
            {


            [self mT__24]; 


             
            }
            break;
        case 12 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:76: T__25 // alt
            {


            [self mT__25]; 


             
            }
            break;
        case 13 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:82: T__26 // alt
            {


            [self mT__26]; 


             
            }
            break;
        case 14 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:88: T__27 // alt
            {


            [self mT__27]; 


             
            }
            break;
        case 15 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:94: T__28 // alt
            {


            [self mT__28]; 


             
            }
            break;
        case 16 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:100: T__29 // alt
            {


            [self mT__29]; 


             
            }
            break;
        case 17 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:106: ID // alt
            {


            [self mID]; 


             
            }
            break;
        case 18 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:109: STRING // alt
            {


            [self mSTRING]; 


             
            }
            break;
        case 19 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:116: BIGSTRING_NO_NL // alt
            {


            [self mBIGSTRING_NO_NL]; 


             
            }
            break;
        case 20 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:132: BIGSTRING // alt
            {


            [self mBIGSTRING]; 


             
            }
            break;
        case 21 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:142: ANONYMOUS_TEMPLATE // alt
            {


            [self mANONYMOUS_TEMPLATE]; 


             
            }
            break;
        case 22 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:161: COMMENT // alt
            {


            [self mCOMMENT]; 


             
            }
            break;
        case 23 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:169: LINE_COMMENT // alt
            {


            [self mLINE_COMMENT]; 


             
            }
            break;
        case 24 : ;
            // /Users/acondit/source/antlr/code/stringtemplate4/objc/main/compiler/Group.g:1:182: WS // alt
            {


            [self mWS]; 


             
            }
            break;

    }

}

@end /* end of GroupLexer implementation line 397 */